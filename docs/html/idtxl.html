
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>idtxl package &#8212; IDTxl 1.2.1 documentation</title>
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/pyramid.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Helper functions" href="idtxl_helper.html" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head><body>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="idtxl_helper.html" title="Helper functions"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">IDTxl 1.2.1 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">idtxl package</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="idtxl-package">
<h1>idtxl package<a class="headerlink" href="#idtxl-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-idtxl.data">
<span id="idtxl-data-module"></span><h2>idtxl.data module<a class="headerlink" href="#module-idtxl.data" title="Permalink to this headline">¶</a></h2>
<p>Provide data structures for IDTxl analysis.</p>
<dl class="py class">
<dt id="idtxl.data.Data">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.data.</span></code><code class="sig-name descname"><span class="pre">Data</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'psr'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/data.html#Data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.data.Data" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Store data for information dynamics estimation.</p>
<p>Data takes a 1- to 3-dimensional array representing realisations of random
variables in dimensions: processes, samples (over time), and replications.
If necessary, data reshapes provided realisations to fit the format
expected by IDTxl, which is a 3-dimensional array with axes representing
(process index, sample index, replication index). Indicate the actual order
of dimensions in the provided array in a three-character string, e.g. ‘spr’
for an array with realisations over (1) samples in time, (2) processes, (3)
replications.</p>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data_mute</span> <span class="o">=</span> <span class="n">Data</span><span class="p">()</span>              <span class="c1"># initialise empty data object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data_mute</span><span class="o">.</span><span class="n">generate_mute_data</span><span class="p">()</span>  <span class="c1"># simulate data from MuTE paper</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create data objects with data of various sizes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>  <span class="c1"># 2 procs.,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data_1</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">dim_order</span><span class="o">=</span><span class="s1">&#39;psr&#39;</span><span class="p">)</span>           <span class="c1"># 1000 samples, 5 repl.</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3000</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1000</span><span class="p">))</span>  <span class="c1"># 3 procs.,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data_2</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">dim_order</span><span class="o">=</span><span class="s1">&#39;ps&#39;</span><span class="p">)</span>        <span class="c1"># 1000 samples</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Overwrite data in existing object with random data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data_2</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">data_new</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="simple">
<dt>Note:</dt><dd><p>Realisations are stored as attribute ‘data’. This can only be set via
the ‘set_data()’ method.</p>
</dd>
<dt>Args:</dt><dd><dl class="simple">
<dt>data<span class="classifier">numpy array [optional]</span></dt><dd><p>1/2/3-dimensional array with raw data</p>
</dd>
<dt>dim_order<span class="classifier">string [optional]</span></dt><dd><p>order of dimensions, accepts any combination of the characters
‘p’, ‘s’, and ‘r’ for processes, samples, and replications; must
have the same length as the data dimensionality, e.g., ‘ps’ for a
two-dimensional array of data from several processes over time
(default=’psr’)</p>
</dd>
<dt>normalise<span class="classifier">bool [optional]</span></dt><dd><p>if True, data gets normalised per process (default=True)</p>
</dd>
<dt>seed<span class="classifier">int [optional]</span></dt><dd><p>can be set to a fixed integer to get repetitive results on the
same data with multiple runs of analyses. Otherwise a random
seed is set as default.</p>
</dd>
</dl>
</dd>
<dt>Attributes:</dt><dd><dl class="simple">
<dt>data<span class="classifier">numpy array</span></dt><dd><p>realisations, can only be set via ‘set_data’ method</p>
</dd>
<dt>n_processes<span class="classifier">int</span></dt><dd><p>number of processes</p>
</dd>
<dt>n_replications<span class="classifier">int</span></dt><dd><p>number of replications</p>
</dd>
<dt>n_samples<span class="classifier">int</span></dt><dd><p>number of samples in time</p>
</dd>
<dt>normalise<span class="classifier">bool</span></dt><dd><p>if true, all data gets z-standardised per process</p>
</dd>
<dt>initial_state<span class="classifier">array</span></dt><dd><p>initial state of the seed for shuffled permutations</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="idtxl.data.Data.data">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">data</span></code><a class="headerlink" href="#idtxl.data.Data.data" title="Permalink to this definition">¶</a></dt>
<dd><p>Return data array.</p>
</dd></dl>

<dl class="py method">
<dt id="idtxl.data.Data.generate_logistic_maps_data">
<code class="sig-name descname"><span class="pre">generate_logistic_maps_data</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_replications</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coefficient_matrices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">array([[[0.5,</span> <span class="pre">0.0],</span> <span class="pre">[0.4,</span> <span class="pre">0.5]]])</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noise_std</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/data.html#Data.generate_logistic_maps_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.data.Data.generate_logistic_maps_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate discrete-time coupled-logistic-maps time series.</p>
<p>Generate data and overwrite the instance’s current data.</p>
<p>The implemented logistic map function is f(x) = 4 * x * (1 - x).</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>n_samples<span class="classifier">int [optional]</span></dt><dd><p>number of samples simulated for each process and replication</p>
</dd>
<dt>n_replications<span class="classifier">int [optional]</span></dt><dd><p>number of replications</p>
</dd>
<dt>coefficient_matrices<span class="classifier">numpy array [optional]</span></dt><dd><p>coefficient matrices: numpy array with dimensions
(order, number of processes, number of processes). Each
square coefficient matrix corresponds to a lag, starting from
lag=1. The total number of provided matrices implicitly
determines the order of the stochastic process.
(default = np.array([[[0.5, 0], [0.4, 0.5]]]))</p>
</dd>
<dt>noise_std<span class="classifier">float [optional]</span></dt><dd><p>standard deviation of uncorrelated Gaussian noise
(default = 0.1)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.data.Data.generate_mute_data">
<code class="sig-name descname"><span class="pre">generate_mute_data</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_replications</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/data.html#Data.generate_mute_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.data.Data.generate_mute_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate example data for a 5-process network.</p>
<p>Generate example data and overwrite the instance’s current data. The
network is used as an example the paper on the MuTE toolbox (Montalto,
PLOS ONE, 2014, eq. 14) and was orginially proposed by Baccala &amp;
Sameshima (2001). The network consists of five autoregressive (AR)
processes with model orders 2 and the following (non-linear) couplings:</p>
<p>0 -&gt; 1, u = 2 (non-linear)
0 -&gt; 2, u = 3
0 -&gt; 3, u = 2 (non-linear)
3 -&gt; 4, u = 1
4 -&gt; 3, u = 1</p>
<p>References:</p>
<ul class="simple">
<li><p>Montalto, A., Faes, L., &amp; Marinazzo, D. (2014) MuTE: A MATLAB toolbox
to compare established and novel estimators of the multivariate
transfer entropy. PLoS ONE 9(10): e109462.
<a class="reference external" href="https://doi.org/10.1371/journal.pone.0109462">https://doi.org/10.1371/journal.pone.0109462</a></p></li>
<li><p>Baccala, L.A. &amp; Sameshima, K. (2001). Partial directed coherence: a
new concept in neural structure determination. Biol Cybern 84:
463–474. <a class="reference external" href="https://doi.org/10.1007/PL00007990">https://doi.org/10.1007/PL00007990</a></p></li>
</ul>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>n_samples<span class="classifier">int</span></dt><dd><p>number of samples simulated for each process and replication</p>
</dd>
<dt>n_replications<span class="classifier">int</span></dt><dd><p>number of replications</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.data.Data.generate_var_data">
<code class="sig-name descname"><span class="pre">generate_var_data</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_replications</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coefficient_matrices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">array([[[0.5,</span> <span class="pre">0.0],</span> <span class="pre">[0.4,</span> <span class="pre">0.5]]])</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noise_std</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/data.html#Data.generate_var_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.data.Data.generate_var_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate discrete-time VAR (vector autoregressive) time series.</p>
<p>Generate data and overwrite the instance’s current data.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>n_samples<span class="classifier">int [optional]</span></dt><dd><p>number of samples simulated for each process and replication</p>
</dd>
<dt>n_replications<span class="classifier">int [optional]</span></dt><dd><p>number of replications</p>
</dd>
<dt>coefficient_matrices<span class="classifier">numpy array [optional]</span></dt><dd><p>coefficient matrices: numpy array with dimensions
(VAR order, number of processes, number of processes). Each
square coefficient matrix corresponds to a lag, starting from
lag=1. The total number of provided matrices implicitly
determines the order of the VAR process.
(default = np.array([[[0.5, 0], [0.4, 0.5]]]))</p>
</dd>
<dt>noise_std<span class="classifier">float [optional]</span></dt><dd><p>standard deviation of uncorrelated Gaussian noise
(default = 0.1)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.data.Data.get_realisations">
<code class="sig-name descname"><span class="pre">get_realisations</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">current_value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shuffle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/data.html#Data.get_realisations"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.data.Data.get_realisations" title="Permalink to this definition">¶</a></dt>
<dd><p>Return realisations for a list of indices.</p>
<p>Return realisations for indices in list. Optionally, realisations can
be shuffled to create surrogate data for statistical testing. For
shuffling, data blocks are permuted over replications while their
temporal order stays intact within replications:</p>
<dl>
<dt>Original data:</dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 22%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 8%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>repl. ind.</p></td>
<td><p>1 1 1 1</p></td>
<td><p>2 2 2 2</p></td>
<td><p>3 3 3 3</p></td>
<td><p>4 4 4 4</p></td>
<td><p>5 5 5 5</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-even"><td><p>sample index</p></td>
<td><p>1 2 3 4</p></td>
<td><p>1 2 3 4</p></td>
<td><p>1 2 3 4</p></td>
<td><p>1 2 3 4</p></td>
<td><p>1 2 3 4</p></td>
<td><p>…</p></td>
</tr>
</tbody>
</table>
</dd>
<dt>Shuffled data:</dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 22%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 8%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>repl. ind.</p></td>
<td><p>3 3 3 3</p></td>
<td><p>1 1 1 1</p></td>
<td><p>4 4 4 4</p></td>
<td><p>2 2 2 2</p></td>
<td><p>5 5 5 5</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-even"><td><p>sample index</p></td>
<td><p>1 2 3 4</p></td>
<td><p>1 2 3 4</p></td>
<td><p>1 2 3 4</p></td>
<td><p>1 2 3 4</p></td>
<td><p>1 2 3 4</p></td>
<td><p>…</p></td>
</tr>
</tbody>
</table>
</dd>
<dt>Args:</dt><dd><dl class="simple">
<dt>idx_list: list of tuples</dt><dd><p>variable indices</p>
</dd>
<dt>current_value<span class="classifier">tuple</span></dt><dd><p>index of the current value in current analysis, has to have the
form (idx process, idx sample); if current_value == idx, all
samples for a process are returned</p>
</dd>
<dt>shuffle: bool</dt><dd><p>if true permute blocks of replications over trials</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>numpy array</dt><dd><p>realisations with dimensions (no. samples * no.replications) x
number of indices</p>
</dd>
<dt>numpy array</dt><dd><p>replication index for each realisation with dimensions (no.
samples * no.replications) x number of indices</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.data.Data.get_seed">
<code class="sig-name descname"><span class="pre">get_seed</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/data.html#Data.get_seed"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.data.Data.get_seed" title="Permalink to this definition">¶</a></dt>
<dd><p>return the initial seed of the data</p>
</dd></dl>

<dl class="py method">
<dt id="idtxl.data.Data.get_state">
<code class="sig-name descname"><span class="pre">get_state</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/data.html#Data.get_state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.data.Data.get_state" title="Permalink to this definition">¶</a></dt>
<dd><p>return the current state of the random seed</p>
</dd></dl>

<dl class="py method">
<dt id="idtxl.data.Data.n_realisations">
<code class="sig-name descname"><span class="pre">n_realisations</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">current_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/data.html#Data.n_realisations"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.data.Data.n_realisations" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of realisations over samples and replications.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>current_value<span class="classifier">tuple [optional]</span></dt><dd><p>reference point for calculation of number of realisations
(e.g. when using an embedding of length k, we count
realisations from the k+1th sample because we loose the first k
samples to the embedding); if no current_value is provided, the
number of all samples is used</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.data.Data.n_realisations_repl">
<code class="sig-name descname"><span class="pre">n_realisations_repl</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/data.html#Data.n_realisations_repl"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.data.Data.n_realisations_repl" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of realisations over replications.</p>
</dd></dl>

<dl class="py method">
<dt id="idtxl.data.Data.n_realisations_samples">
<code class="sig-name descname"><span class="pre">n_realisations_samples</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">current_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/data.html#Data.n_realisations_samples"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.data.Data.n_realisations_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of realisations over samples.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>current_value<span class="classifier">tuple [optional]</span></dt><dd><p>reference point for calculation of number of realisations
(e.g. when using an embedding of length k, the current value is
at sample k + 1; we thus count realisations from the k + 1st
sample because we loose the first k samples to the embedding)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.data.Data.permute_replications">
<code class="sig-name descname"><span class="pre">permute_replications</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">current_value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_list</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/data.html#Data.permute_replications"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.data.Data.permute_replications" title="Permalink to this definition">¶</a></dt>
<dd><p>Return realisations with permuted replications (time stays intact).</p>
<p>Create surrogate data by permuting realisations over replications while
keeping the temporal structure (order of samples) intact. Return
realisations for all indices in the list, where an index is expected to
have the form (process index, sample index). Realisations are permuted
block-wise by permuting the order of replications:</p>
<dl>
<dt>Original data:</dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 22%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 8%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>repl. ind.</p></td>
<td><p>1 1 1 1</p></td>
<td><p>2 2 2 2</p></td>
<td><p>3 3 3 3</p></td>
<td><p>4 4 4 4</p></td>
<td><p>5 5 5 5</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-even"><td><p>sample index</p></td>
<td><p>1 2 3 4</p></td>
<td><p>1 2 3 4</p></td>
<td><p>1 2 3 4</p></td>
<td><p>1 2 3 4</p></td>
<td><p>1 2 3 4</p></td>
<td><p>…</p></td>
</tr>
</tbody>
</table>
</dd>
<dt>Permuted data:</dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 22%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 8%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>repl. ind.</p></td>
<td><p>3 3 3 3</p></td>
<td><p>1 1 1 1</p></td>
<td><p>4 4 4 4</p></td>
<td><p>2 2 2 2</p></td>
<td><p>5 5 5 5</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-even"><td><p>sample index</p></td>
<td><p>1 2 3 4</p></td>
<td><p>1 2 3 4</p></td>
<td><p>1 2 3 4</p></td>
<td><p>1 2 3 4</p></td>
<td><p>1 2 3 4</p></td>
<td><p>…</p></td>
</tr>
</tbody>
</table>
</dd>
<dt>Args:</dt><dd><dl class="simple">
<dt>current_value<span class="classifier">tuple</span></dt><dd><p>index of the current_value in the data</p>
</dd>
<dt>idx_list<span class="classifier">list of tuples</span></dt><dd><p>indices of variables</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>numpy array</dt><dd><p>permuted realisations with dimensions replications x number of
indices</p>
</dd>
<dt>numpy array</dt><dd><p>replication index for each realisation</p>
</dd>
</dl>
</dd>
<dt>Raises:</dt><dd><p>TypeError if idx_realisations is not a list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.data.Data.permute_samples">
<code class="sig-name descname"><span class="pre">permute_samples</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">current_value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">perm_settings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/data.html#Data.permute_samples"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.data.Data.permute_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Return realisations with permuted samples (repl. stays intact).</p>
<p>Create surrogate data by permuting realisations over samples (time)
while keeping the order of replications intact. Surrogates can be
created for multiple variables in parallel, where variables are
provided as a list of indices. An index is expected to have the form
(process index, sample index).</p>
<p>Permuting samples in time is the fall-back option for surrogate data
creation. The default method for surrogate data creation is the
permutation of replications, while keeping the order of samples in time
intact. If the number of replications is too small to allow for a
sufficient number of permutations for the generation of surrogate data,
permutation of samples in time is chosen instead.</p>
<p>Different permutation strategies can be chosen to permute realisations
in time. Note that if data consists of multiple replications, within
each replication, samples are shuffled following the same permutation
pattern:</p>
<dl>
<dt>Original data:</dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 7%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>repl. ind.</p></td>
<td><p>1 1 1 1 1 1 1 1</p></td>
<td><p>2 2 2 2 2 2 2 2</p></td>
<td><p>3 3 3 3 3 3 3 3</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-even"><td><p>sample index</p></td>
<td><p>1 2 3 4 5 6 7 8</p></td>
<td><p>1 2 3 4 5 6 7 8</p></td>
<td><p>1 2 3 4 5 6 7 8</p></td>
<td><p>…</p></td>
</tr>
</tbody>
</table>
</dd>
<dt>Circular shift by a random number of samples, e.g. 4 samples:</dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 7%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>repl. ind.</p></td>
<td><p>1 1 1 1 1 1 1 1</p></td>
<td><p>2 2 2 2 2 2 2 2</p></td>
<td><p>3 3 3 3 3 3 3 3</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-even"><td><p>sample index</p></td>
<td><p>5 6 7 8 1 2 3 4</p></td>
<td><p>5 6 7 8 1 2 3 4</p></td>
<td><p>5 6 7 8 1 2 3 4</p></td>
<td><p>…</p></td>
</tr>
</tbody>
</table>
</dd>
<dt>Permute blocks of 3 samples:</dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 7%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>repl. ind.</p></td>
<td><p>1 1 1 1 1 1 1 1</p></td>
<td><p>2 2 2 2 2 2 2 2</p></td>
<td><p>3 3 3 3 3 3 3 3</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-even"><td><p>sample index</p></td>
<td><p>4 5 6 7 8 1 2 3</p></td>
<td><p>4 5 6 7 8 1 2 3</p></td>
<td><p>4 5 6 7 8 1 2 3</p></td>
<td><p>…</p></td>
</tr>
</tbody>
</table>
</dd>
<dt>Permute data locally within a range of 4 samples:</dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 7%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>repl. ind.</p></td>
<td><p>1 1 1 1 1 1 1 1</p></td>
<td><p>2 2 2 2 2 2 2 2</p></td>
<td><p>3 3 3 3 3 3 3 3</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-even"><td><p>sample index</p></td>
<td><p>1 2 4 3 8 5 6 7</p></td>
<td><p>1 2 4 3 8 5 6 7</p></td>
<td><p>1 2 4 3 8 5 6 7</p></td>
<td><p>…</p></td>
</tr>
</tbody>
</table>
</dd>
<dt>Random permutation:</dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 7%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>repl. ind.</p></td>
<td><p>1 1 1 1 1 1 1 1</p></td>
<td><p>2 2 2 2 2 2 2 2</p></td>
<td><p>3 3 3 3 3 3 3 3</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-even"><td><p>sample index</p></td>
<td><p>4 2 5 7 1 3 2 6</p></td>
<td><p>4 2 5 7 1 3 2 6</p></td>
<td><p>4 2 5 7 1 3 2 6</p></td>
<td><p>…</p></td>
</tr>
</tbody>
</table>
</dd>
<dt>Args:</dt><dd><dl>
<dt>current_value<span class="classifier">tuple</span></dt><dd><p>index of the current_value in the data</p>
</dd>
<dt>idx_list<span class="classifier">list of tuples</span></dt><dd><p>indices of variables</p>
</dd>
<dt>perm_settings<span class="classifier">dict</span></dt><dd><p>settings specifying the allowed permutations:</p>
<ul>
<li><p>perm_type : str
permutation type, can be</p>
<blockquote>
<div><ul class="simple">
<li><p>‘random’: swaps samples at random,</p></li>
<li><p>‘circular’: shifts time series by a random number of
samples</p></li>
<li><p>‘block’: swaps blocks of samples,</p></li>
<li><p>‘local’: swaps samples within a given range, or</p></li>
</ul>
</div></blockquote>
</li>
<li><p>additional settings depending on the perm_type (n is the
number of samples):</p>
<blockquote>
<div><ul>
<li><p>if perm_type == ‘circular’:</p>
<dl class="simple">
<dt>‘max_shift’<span class="classifier">int</span></dt><dd><p>the maximum number of samples for shifting
(e.g., number of samples / 2)</p>
</dd>
</dl>
</li>
<li><p>if perm_type == ‘block’:</p>
<dl class="simple">
<dt>‘block_size’<span class="classifier">int</span></dt><dd><p>no. samples per block (e.g., number of samples / 10)</p>
</dd>
<dt>‘perm_range’<span class="classifier">int</span></dt><dd><p>range in which blocks can be swapped (e.g., number
of samples / block_size)</p>
</dd>
</dl>
</li>
<li><p>if perm_type == ‘local’:</p>
<dl class="simple">
<dt>‘perm_range’<span class="classifier">int</span></dt><dd><p>range in samples over which realisations can be
permuted (e.g., number of samples / 10)</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>numpy array</dt><dd><p>permuted realisations with dimensions replications x number of
indices</p>
</dd>
<dt>numpy array</dt><dd><p>sample index for each realisation</p>
</dd>
</dl>
</dd>
<dt>Raises:</dt><dd><p>TypeError if idx_realisations is not a list</p>
</dd>
<dt>Note:</dt><dd><p>This permutation scheme is the fall-back option if surrogate data
can not be created by shuffling replications because the number of
replications is too small to generate the requested number of
permutations.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.data.Data.set_data">
<code class="sig-name descname"><span class="pre">set_data</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim_order</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/data.html#Data.set_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.data.Data.set_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Overwrite data in an existing Data object.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>data<span class="classifier">numpy array</span></dt><dd><p>1- to 3-dimensional array of realisations</p>
</dd>
<dt>dim_order<span class="classifier">string</span></dt><dd><p>order of dimensions, accepts any combination of the characters
‘p’, ‘s’, and ‘r’ for processes, samples, and replications;
must have the same length as number of dimensions in data</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.data.Data.slice_permute_replications">
<code class="sig-name descname"><span class="pre">slice_permute_replications</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">process</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/data.html#Data.slice_permute_replications"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.data.Data.slice_permute_replications" title="Permalink to this definition">¶</a></dt>
<dd><p>Return data slice with permuted replications (time stays intact).</p>
<p>Create surrogate data by permuting realisations over replications while
keeping the temporal structure (order of samples) intact. Return
realisations for all indices in the list, where an index is expected to
have the form (process index, sample index). Realisations are permuted
block-wise by permuting the order of replications</p>
</dd></dl>

<dl class="py method">
<dt id="idtxl.data.Data.slice_permute_samples">
<code class="sig-name descname"><span class="pre">slice_permute_samples</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">process</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">perm_settings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/data.html#Data.slice_permute_samples"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.data.Data.slice_permute_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Return slice of data with permuted samples (repl. stays intact).</p>
<p>Create surrogate data by permuting data in a slice over samples (time)
while keeping the order of replications intact. Return slice for the
entry specified by ‘process’. Realisations are permuted according to
the settings specified in perm_settings:</p>
<dl>
<dt>Original data:</dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 7%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>repl. ind.</p></td>
<td><p>1 1 1 1 1 1 1 1</p></td>
<td><p>2 2 2 2 2 2 2 2</p></td>
<td><p>3 3 3 3 3 3 3 3</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-even"><td><p>sample index</p></td>
<td><p>1 2 3 4 5 6 7 8</p></td>
<td><p>1 2 3 4 5 6 7 8</p></td>
<td><p>1 2 3 4 5 6 7 8</p></td>
<td><p>…</p></td>
</tr>
</tbody>
</table>
</dd>
<dt>Circular shift by 2, 6, and 4 samples:</dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 7%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>repl. ind.</p></td>
<td><p>1 1 1 1 1 1 1 1</p></td>
<td><p>2 2 2 2 2 2 2 2</p></td>
<td><p>3 3 3 3 3 3 3 3</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-even"><td><p>sample index</p></td>
<td><p>7 8 1 2 3 4 5 6</p></td>
<td><p>3 4 5 6 7 8 1 2</p></td>
<td><p>5 6 7 8 1 2 3 4</p></td>
<td><p>…</p></td>
</tr>
</tbody>
</table>
</dd>
<dt>Permute blocks of 3 samples:</dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 7%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>repl. ind.</p></td>
<td><p>1 1 1 1 1 1 1 1</p></td>
<td><p>2 2 2 2 2 2 2 2</p></td>
<td><p>3 3 3 3 3 3 3 3</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-even"><td><p>sample index</p></td>
<td><p>4 5 6 7 8 1 2 3</p></td>
<td><p>1 2 3 7 8 4 5 6</p></td>
<td><p>7 8 4 5 6 1 2 3</p></td>
<td><p>…</p></td>
</tr>
</tbody>
</table>
</dd>
<dt>Permute data locally within a range of 4 samples:</dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 7%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>repl. ind.</p></td>
<td><p>1 1 1 1 1 1 1 1</p></td>
<td><p>2 2 2 2 2 2 2 2</p></td>
<td><p>3 3 3 3 3 3 3 3</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-even"><td><p>sample index</p></td>
<td><p>1 2 4 3 8 5 6 7</p></td>
<td><p>4 1 2 3 5 7 8 6</p></td>
<td><p>3 1 2 4 8 5 6 7</p></td>
<td><p>…</p></td>
</tr>
</tbody>
</table>
</dd>
<dt>Random permutation:</dt><dd><table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 7%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>repl. ind.</p></td>
<td><p>1 1 1 1 1 1 1 1</p></td>
<td><p>2 2 2 2 2 2 2 2</p></td>
<td><p>3 3 3 3 3 3 3 3</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-even"><td><p>sample index</p></td>
<td><p>4 2 5 7 1 3 2 6</p></td>
<td><p>7 5 3 4 2 1 8 5</p></td>
<td><p>1 2 4 3 6 8 7 5</p></td>
<td><p>…</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>
<p>Permuting samples is the fall-back option for surrogate creation if the
number of replications is too small to allow for a sufficient number of
permutations for the generation of surrogate data.</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>process<span class="classifier">int</span></dt><dd><p>process for which to return data slice</p>
</dd>
<dt>perm_settings<span class="classifier">dict</span></dt><dd><p>settings specifying the allowed permutations:</p>
<ul>
<li><p>perm_type : str
permutation type, can be</p>
<blockquote>
<div><ul class="simple">
<li><p>‘circular’: shifts time series by a random
number of samples</p></li>
<li><p>‘block’: swaps blocks of samples,</p></li>
<li><p>‘local’: swaps samples within a given range, or</p></li>
<li><p>‘random’: swaps samples at random,</p></li>
</ul>
</div></blockquote>
</li>
<li><p>additional settings depending on the perm_type (n is the
number of samples):</p>
<blockquote>
<div><ul>
<li><p>if perm_type == ‘circular’:</p>
<dl class="simple">
<dt>‘max_shift’<span class="classifier">int</span></dt><dd><p>the maximum number of samples for shifting
(default=n/2)</p>
</dd>
</dl>
</li>
<li><p>if perm_type == ‘block’:</p>
<dl class="simple">
<dt>‘block_size’<span class="classifier">int</span></dt><dd><p>no. samples per block (default=n/10)</p>
</dd>
<dt>‘perm_range’<span class="classifier">int</span></dt><dd><p>range in which blocks can be swapped (default=max)</p>
</dd>
</dl>
</li>
<li><p>if perm_type == ‘local’:</p>
<dl class="simple">
<dt>‘perm_range’<span class="classifier">int</span></dt><dd><p>range in samples over which realisations can be
permuted (default=n/10)</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>numpy array</dt><dd><p>data slice with data permuted over samples with dimensions
samples x number of replications</p>
</dd>
<dt>numpy array</dt><dd><p>index of permutet samples</p>
</dd>
</dl>
</dd>
<dt>Note:</dt><dd><p>This permutation scheme is the fall-back option if the number of
replications is too small to allow a sufficient number of
permutations for the generation of surrogate data.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-idtxl.bivariate_te">
<span id="idtxl-bivariate-te-module"></span><h2>idtxl.bivariate_te module<a class="headerlink" href="#module-idtxl.bivariate_te" title="Permalink to this headline">¶</a></h2>
<p>Perform network inference using multivarate transfer entropy.</p>
<p>Estimate multivariate transfer entropy (TE) for network inference using a
greedy approach with maximum statistics to generate a non-uniform embedding
(Faes, 2011; Lizier, 2012).</p>
<dl class="simple">
<dt>Note:</dt><dd><p>Written for Python 3.4+</p>
</dd>
</dl>
<dl class="py class">
<dt id="idtxl.bivariate_te.BivariateTE">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.bivariate_te.</span></code><code class="sig-name descname"><span class="pre">BivariateTE</span></code><a class="reference internal" href="_modules/idtxl/bivariate_te.html#BivariateTE"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.bivariate_te.BivariateTE" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.network_inference.NetworkInferenceTE" title="idtxl.network_inference.NetworkInferenceTE"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.network_inference.NetworkInferenceTE</span></code></a>, <a class="reference internal" href="#idtxl.network_inference.NetworkInferenceBivariate" title="idtxl.network_inference.NetworkInferenceBivariate"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.network_inference.NetworkInferenceBivariate</span></code></a></p>
<p>Perform network inference using bivariate transfer entropy.</p>
<p>Perform network inference using bivariate transfer entropy (TE). To
perform network inference call analyse_network() on the whole network or a
set of nodes or call analyse_single_target() to estimate TE for a single
target. See docstrings of the two functions for more information.</p>
<p>References:</p>
<ul class="simple">
<li><p>Schreiber, T. (2000). Measuring Information Transfer. Phys Rev Lett,
85(2), 461–464. <a class="reference external" href="http://doi.org/10.1103/PhysRevLett.85.461">http://doi.org/10.1103/PhysRevLett.85.461</a></p></li>
<li><p>Vicente, R., Wibral, M., Lindner, M., &amp; Pipa, G. (2011). Transfer
entropy-a model-free measure of effective connectivity for the
neurosciences. J Comp Neurosci, 30(1), 45–67.
<a class="reference external" href="http://doi.org/10.1007/s10827-010-0262-3">http://doi.org/10.1007/s10827-010-0262-3</a></p></li>
<li><p>Lizier, J. T., &amp; Rubinov, M. (2012). Multivariate construction of
effective computational networks from observational data. Max Planck
Institute: Preprint. Retrieved from
<a class="reference external" href="http://www.mis.mpg.de/preprints/2012/preprint2012_25.pdf">http://www.mis.mpg.de/preprints/2012/preprint2012_25.pdf</a></p></li>
<li><p>Faes, L., Nollo, G., &amp; Porta, A. (2011). Information-based detection
of nonlinear Granger causality in multivariate processes via a
nonuniform embedding technique. Phys Rev E, 83, 1–15.
<a class="reference external" href="http://doi.org/10.1103/PhysRevE.83.051112">http://doi.org/10.1103/PhysRevE.83.051112</a></p></li>
</ul>
<dl class="simple">
<dt>Attributes:</dt><dd><dl class="simple">
<dt>source_set<span class="classifier">list</span></dt><dd><p>indices of source processes tested for their influence on the
target</p>
</dd>
<dt>target<span class="classifier">list</span></dt><dd><p>index of target process</p>
</dd>
<dt>settings<span class="classifier">dict</span></dt><dd><p>analysis settings</p>
</dd>
<dt>current_value<span class="classifier">tuple</span></dt><dd><p>index of the current value in TE estimation, (idx process,
idx sample)</p>
</dd>
<dt>selected_vars_full<span class="classifier">list of tuples</span></dt><dd><p>samples in the full conditional set, (idx process, idx sample)</p>
</dd>
<dt>selected_vars_sources<span class="classifier">list of tuples</span></dt><dd><p>source samples in the conditional set, (idx process, idx sample)</p>
</dd>
<dt>selected_vars_target<span class="classifier">list of tuples</span></dt><dd><p>target samples in the conditional set, (idx process, idx sample)</p>
</dd>
<dt>pvalue_omnibus<span class="classifier">float</span></dt><dd><p>p-value of the omnibus test</p>
</dd>
<dt>pvalues_sign_sources<span class="classifier">numpy array</span></dt><dd><p>array of p-values for TE from individual sources to the target</p>
</dd>
<dt>statistic_omnibus<span class="classifier">float</span></dt><dd><p>joint TE from all sources to the target</p>
</dd>
<dt>statistic_sign_sources<span class="classifier">numpy array</span></dt><dd><p>raw TE values from individual sources to the target</p>
</dd>
<dt>sign_ominbus<span class="classifier">bool</span></dt><dd><p>statistical significance of the over-all TE</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="idtxl.bivariate_te.BivariateTE.analyse_network">
<code class="sig-name descname"><span class="pre">analyse_network</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sources</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/bivariate_te.html#BivariateTE.analyse_network"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.bivariate_te.BivariateTE.analyse_network" title="Permalink to this definition">¶</a></dt>
<dd><p>Find bivariate transfer entropy between all nodes in the network.</p>
<p>Estimate bivariate transfer entropy (TE) between all nodes in the
network or between selected sources and targets.</p>
<dl class="simple">
<dt>Note:</dt><dd><p>For a detailed description of the algorithm and settings see
documentation of the analyse_single_target() method and references
in the class docstring.</p>
</dd>
</dl>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Data</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">generate_mute_data</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;cmi_estimator&#39;</span><span class="p">:</span>  <span class="s1">&#39;JidtKraskovCMI&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_min_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_omnibus&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_seq&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;max_lag&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;min_lag&#39;</span><span class="p">:</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">network_analysis</span> <span class="o">=</span> <span class="n">BivariateTE</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">network_analysis</span><span class="o">.</span><span class="n">analyse_network</span><span class="p">(</span><span class="n">settings</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>parameters for estimation and statistical testing, see
documentation of analyse_single_target() for details, settings
can further contain</p>
<ul class="simple">
<li><p>verbose : bool [optional] - toggle console output
(default=True)</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data for analysis</p>
</dd>
<dt>targets<span class="classifier">list of int | ‘all’ [optional]</span></dt><dd><p>index of target processes (default=’all’)</p>
</dd>
<dt>sources<span class="classifier">list of int | list of list | ‘all’  [optional]</span></dt><dd><p>indices of source processes for each target (default=’all’);
if ‘all’, all network nodes excluding the target node are
considered as potential sources and tested;
if list of int, the source specified by each int is tested as
a potential source for the target with the same index or a
single target;
if list of list, sources specified in each inner list are
tested for the target with the same index</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>ResultsNetworkInference instance</dt><dd><p>results of network inference, see documentation of
ResultsNetworkInference()</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.bivariate_te.BivariateTE.analyse_single_target">
<code class="sig-name descname"><span class="pre">analyse_single_target</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sources</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/bivariate_te.html#BivariateTE.analyse_single_target"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.bivariate_te.BivariateTE.analyse_single_target" title="Permalink to this definition">¶</a></dt>
<dd><p>Find bivariate transfer entropy between sources and a target.</p>
<p>Find bivariate transfer entropy (TE) between all potential source
processes and the target process. Uses bivariate, non-uniform embedding
found through information maximisation.</p>
<p>Bivariate TE is calculated in four steps:</p>
<ol class="arabic simple">
<li><p>find all relevant variables in the target processes’ own past, by
iteratively adding candidate variables that have significant
conditional mutual information (CMI) with the current value
(conditional on all variables that were added previously)</p></li>
<li><p>find all relevant variables in the single source processes’ pasts
(again by finding all candidates with significant CMI); treat each
potential source process separately, i.e., the CMI is calculated
with respect to already selected variables from the target’s past
and from the current processes’ past only</p></li>
<li><p>prune the final conditional set for each link (i.e., each
process-target pairing): test the CMI between each variable in
the final set and the current value, conditional on all other
variables in the final set of the current link</p></li>
<li><p>statistics on the final set of sources (test for over-all transfer
between the final conditional set and the current value, and for
significant transfer of all individual variables in the set)</p></li>
</ol>
<dl class="simple">
<dt>Note:</dt><dd><p>For a further description of the algorithm see references in the
class docstring.</p>
</dd>
</dl>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Data</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">generate_mute_data</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;cmi_estimator&#39;</span><span class="p">:</span>  <span class="s1">&#39;JidtKraskovCMI&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_min_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_omnibus&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_seq&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;max_lag&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;min_lag&#39;</span><span class="p">:</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">target</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">network_analysis</span> <span class="o">=</span> <span class="n">BivariateTE</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">network_analysis</span><span class="o">.</span><span class="n">analyse_single_target</span><span class="p">(</span><span class="n">settings</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                                 <span class="n">data</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                                 <span class="n">sources</span><span class="p">)</span>
</pre></div>
</div>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>parameters for estimation and statistical testing:</p>
<ul class="simple">
<li><p>cmi_estimator : str - estimator to be used for CMI
calculation (for estimator settings see the documentation in
the estimators_* modules)</p></li>
<li><p>max_lag_sources : int - maximum temporal search depth for
candidates in the sources’ past in samples</p></li>
<li><p>min_lag_sources : int - minimum temporal search depth for
candidates in the sources’ past in samples</p></li>
<li><p>max_lag_target : int [optional] - maximum temporal search
depth for candidates in the target’s past in samples
(default=same as max_lag_sources)</p></li>
<li><p>tau_sources : int [optional] - spacing between candidates in
the sources’ past in samples (default=1)</p></li>
<li><p>tau_target : int [optional] - spacing between candidates in
the target’s past in samples (default=1)</p></li>
<li><p>n_perm_* : int - number of permutations, where * can be
‘max_stat’, ‘min_stat’, ‘omnibus’, and ‘max_seq’
(default=500)</p></li>
<li><p>alpha_* : float - critical alpha level for statistical
significance, where * can be ‘max_stats’,  ‘min_stats’, and
‘omnibus’ (default=0.05)</p></li>
<li><p>add_conditionals : list of tuples | str [optional] - force
the estimator to add these conditionals when estimating TE;
can either be a list of variables, where each variable is
described as (idx process, lag wrt to current value) or can
be a string: ‘faes’ for Faes-Method (see references)</p></li>
<li><p>permute_in_time : bool [optional] - force surrogate creation
by shuffling realisations in time instead of shuffling
replications; see documentation of Data.permute_samples() for
further settings (default=False)</p></li>
<li><p>verbose : bool [optional] - toggle console output
(default=True)</p></li>
<li><p>write_ckp : bool [optional] - enable checkpointing, writes
analysis state to disk every time a variable is selected;
resume crashed analysis using
network_analysis.resume_checkpoint() (default=False)</p></li>
<li><p>filename_ckp : str [optional] - checkpoint file name (without
extension) (default=’./idtxl_checkpoint’)</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data for analysis</p>
</dd>
<dt>target<span class="classifier">int</span></dt><dd><p>index of target process</p>
</dd>
<dt>sources<span class="classifier">list of int | int | ‘all’ [optional]</span></dt><dd><p>single index or list of indices of source processes
(default=’all’), if ‘all’, all network nodes excluding the
target node are considered as potential sources</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>ResultsNetworkInference instance</dt><dd><p>results of network inference, see documentation of
ResultsNetworkInference()</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-idtxl.bivariate_mi">
<span id="idtxl-bivariate-mi-module"></span><h2>idtxl.bivariate_mi module<a class="headerlink" href="#module-idtxl.bivariate_mi" title="Permalink to this headline">¶</a></h2>
<p>Perform network inference using bivarate mutual information.</p>
<p>Estimate bivariate mutual information (MI) for network inference using a
greedy approach with maximum statistics to generate a non-uniform embedding
(Faes, 2011; Lizier, 2012).</p>
<dl class="simple">
<dt>Note:</dt><dd><p>Written for Python 3.4+</p>
</dd>
</dl>
<dl class="py class">
<dt id="idtxl.bivariate_mi.BivariateMI">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.bivariate_mi.</span></code><code class="sig-name descname"><span class="pre">BivariateMI</span></code><a class="reference internal" href="_modules/idtxl/bivariate_mi.html#BivariateMI"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.bivariate_mi.BivariateMI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.network_inference.NetworkInferenceMI" title="idtxl.network_inference.NetworkInferenceMI"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.network_inference.NetworkInferenceMI</span></code></a>, <a class="reference internal" href="#idtxl.network_inference.NetworkInferenceBivariate" title="idtxl.network_inference.NetworkInferenceBivariate"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.network_inference.NetworkInferenceBivariate</span></code></a></p>
<p>Perform network inference using bivariate mutual information.</p>
<p>Perform network inference using bivariate mutual information (MI). To
perform network inference call analyse_network() on the whole network or a
set of nodes or call analyse_single_target() to estimate MI for a single
target. See docstrings of the two functions for more information.</p>
<p>References:</p>
<ul class="simple">
<li><p>Lizier, J. T., &amp; Rubinov, M. (2012). Multivariate construction of
effective computational networks from observational data. Max Planck
Institute: Preprint. Retrieved from
<a class="reference external" href="http://www.mis.mpg.de/preprints/2012/preprint2012_25.pdf">http://www.mis.mpg.de/preprints/2012/preprint2012_25.pdf</a></p></li>
<li><p>Faes, L., Nollo, G., &amp; Porta, A. (2011). Information-based detection
of nonlinear Granger causality in multivariate processes via a
nonuniform embedding technique. Phys Rev E, 83, 1–15.
<a class="reference external" href="http://doi.org/10.1103/PhysRevE.83.051112">http://doi.org/10.1103/PhysRevE.83.051112</a></p></li>
</ul>
<dl class="simple">
<dt>Attributes:</dt><dd><dl class="simple">
<dt>source_set<span class="classifier">list</span></dt><dd><p>indices of source processes tested for their influence on the
target</p>
</dd>
<dt>target<span class="classifier">list</span></dt><dd><p>index of target process</p>
</dd>
<dt>settings<span class="classifier">dict</span></dt><dd><p>analysis settings</p>
</dd>
<dt>current_value<span class="classifier">tuple</span></dt><dd><p>index of the current value in MI estimation, (idx process,
idx sample)</p>
</dd>
<dt>selected_vars_full<span class="classifier">list of tuples</span></dt><dd><p>samples in the full conditional set, (idx process, idx sample)</p>
</dd>
<dt>selected_vars_sources<span class="classifier">list of tuples</span></dt><dd><p>source samples in the conditional set, (idx process, idx sample)</p>
</dd>
<dt>selected_vars_target<span class="classifier">list of tuples</span></dt><dd><p>target samples in the conditional set, (idx process, idx sample)</p>
</dd>
<dt>pvalue_omnibus<span class="classifier">float</span></dt><dd><p>p-value of the omnibus test</p>
</dd>
<dt>pvalues_sign_sources<span class="classifier">numpy array</span></dt><dd><p>array of p-values for MI from individual sources to the target</p>
</dd>
<dt>mi_omnibus<span class="classifier">float</span></dt><dd><p>joint MI from all sources to the target</p>
</dd>
<dt>mi_sign_sources<span class="classifier">numpy array</span></dt><dd><p>raw MI values from individual sources to the target</p>
</dd>
<dt>sign_ominbus<span class="classifier">bool</span></dt><dd><p>statistical significance of the over-all MI</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="idtxl.bivariate_mi.BivariateMI.analyse_network">
<code class="sig-name descname"><span class="pre">analyse_network</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sources</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/bivariate_mi.html#BivariateMI.analyse_network"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.bivariate_mi.BivariateMI.analyse_network" title="Permalink to this definition">¶</a></dt>
<dd><p>Find bivariate mutual information between all nodes in the network.</p>
<p>Estimate bivariate mutual information (MI) between all nodes in the
network or between selected sources and targets.</p>
<dl class="simple">
<dt>Note:</dt><dd><p>For a detailed description of the algorithm and settings see
documentation of the analyse_single_target() method and references
in the class docstring.</p>
</dd>
</dl>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Data</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">generate_mute_data</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># The algorithm uses a conditional mutual information to</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># construct a non-uniform embedding, hence a CMI- not MI-</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># estimator has to be specified:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;cmi_estimator&#39;</span><span class="p">:</span>  <span class="s1">&#39;JidtKraskovCMI&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_min_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_omnibus&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_seq&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;max_lag&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;min_lag&#39;</span><span class="p">:</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">network_analysis</span> <span class="o">=</span> <span class="n">BivariateMI</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">network_analysis</span><span class="o">.</span><span class="n">analyse_network</span><span class="p">(</span><span class="n">settings</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>parameters for estimation and statistical testing, see
documentation of analyse_single_target() for details, settings
can further contain</p>
<ul class="simple">
<li><p>verbose : bool [optional] - toggle console output
(default=True)</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data for analysis</p>
</dd>
<dt>targets<span class="classifier">list of int | ‘all’ [optional]</span></dt><dd><p>index of target processes (default=’all’)</p>
</dd>
<dt>sources<span class="classifier">list of int | list of list | ‘all’  [optional]</span></dt><dd><p>indices of source processes for each target (default=’all’);
if ‘all’, all network nodes excluding the target node are
considered as potential sources and tested;
if list of int, the source specified by each int is tested as
a potential source for the target with the same index or a
single target;
if list of list, sources specified in each inner list are
tested for the target with the same index</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>dict</dt><dd><p>results for each target, see documentation of
analyse_single_target()</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.bivariate_mi.BivariateMI.analyse_single_target">
<code class="sig-name descname"><span class="pre">analyse_single_target</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sources</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/bivariate_mi.html#BivariateMI.analyse_single_target"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.bivariate_mi.BivariateMI.analyse_single_target" title="Permalink to this definition">¶</a></dt>
<dd><p>Find bivariate mutual information between sources and a target.</p>
<p>Find bivariate mutual information (MI) between all potential source
processes and the target process. Uses bivariate, non-uniform embedding
found through information maximisation</p>
<p>MI is calculated in three steps:</p>
<ol class="arabic simple">
<li><p>find all relevant variables in a single source processes’ past, by
iteratively adding candidate variables that have significant
conditional mutual information (CMI) with the current value
(conditional on all variables that were added previously)</p></li>
<li><p>prune the final conditional set for each link (i.e., each
process-target pairing): test the CMI between each variable in
the final set and the current value, conditional on all other
variables in the final set of the current link; treat each
potential source process separately, i.e., the CMI is calculated
with respect to already selected variables the current processes’
past only</p></li>
<li><p>statistics on the final set of sources (test for over-all transfer
between the final conditional set and the current value, and for
significant transfer of all individual variables in the set)</p></li>
</ol>
<dl class="simple">
<dt>Note:</dt><dd><p>For a further description of the algorithm see references in the
class docstring.</p>
</dd>
</dl>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Data</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">generate_mute_data</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># The algorithm uses a conditional mutual information to</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># construct a non-uniform embedding, hence a CMI- not MI-</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># estimator has to be specified:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;cmi_estimator&#39;</span><span class="p">:</span>  <span class="s1">&#39;JidtKraskovCMI&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_min_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_omnibus&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_seq&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;max_lag&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;min_lag&#39;</span><span class="p">:</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">target</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">network_analysis</span> <span class="o">=</span> <span class="n">BivariateMI</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">network_analysis</span><span class="o">.</span><span class="n">analyse_single_target</span><span class="p">(</span><span class="n">settings</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                                 <span class="n">data</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                                 <span class="n">sources</span><span class="p">)</span>
</pre></div>
</div>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>parameters for estimation and statistical testing:</p>
<ul class="simple">
<li><p>cmi_estimator : str - estimator to be used for CMI
calculation (for estimator settings see the documentation in
the estimators_* modules)</p></li>
<li><p>max_lag_sources : int - maximum temporal search depth for
candidates in the sources’ past in samples</p></li>
<li><p>min_lag_sources : int - minimum temporal search depth for
candidates in the sources’ past in samples</p></li>
<li><p>tau_sources : int [optional] - spacing between candidates in
the sources’ past in samples (default=1)</p></li>
<li><p>n_perm_* : int - number of permutations, where * can be
‘max_stat’, ‘min_stat’, ‘omnibus’, and ‘max_seq’
(default=500)</p></li>
<li><p>alpha_* : float - critical alpha level for statistical
significance, where * can be ‘max_stats’,  ‘min_stats’, and
‘omnibus’ (default=0.05)</p></li>
<li><p>add_conditionals : list of tuples | str [optional] - force
the estimator to add these conditionals when estimating MI;
can either be a list of variables, where each variable is
described as (idx process, lag wrt to current value) or can
be a string: ‘faes’ for Faes-Method (see references)</p></li>
<li><p>permute_in_time : bool [optional] - force surrogate creation
by shuffling realisations in time instead of shuffling
replications; see documentation of Data.permute_samples() for
further settings (default=False)</p></li>
<li><p>verbose : bool [optional] - toggle console output
(default=True)</p></li>
<li><p>write_ckp : bool [optional] - enable checkpointing, writes
analysis state to disk every time a variable is selected;
resume crashed analysis using
network_analysis.resume_checkpoint() (default=False)</p></li>
<li><p>filename_ckp : str [optional] - checkpoint file name (without
extension) (default=’./idtxl_checkpoint’)</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data for analysis</p>
</dd>
<dt>target<span class="classifier">int</span></dt><dd><p>index of target process</p>
</dd>
<dt>sources<span class="classifier">list of int | int | ‘all’ [optional]</span></dt><dd><p>single index or list of indices of source processes
(default=’all’), if ‘all’, all network nodes excluding the
target node are considered as potential sources</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>dict</dt><dd><p>results consisting of sets of selected variables as (full set,
variables from the sources’ past), pvalues and MI for each
selected variable, the current value for this analysis, results
for omnibus test (joint MI between all selected source
variables and the target, omnibus MI, p-value, and
significance); NOTE that all variables are listed as tuples
(process, lag wrt. current value)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-idtxl.bivariate_pid">
<span id="idtxl-bivariate-pid-module"></span><h2>idtxl.bivariate_pid module<a class="headerlink" href="#module-idtxl.bivariate_pid" title="Permalink to this headline">¶</a></h2>
<p>Estimate partial information decomposition (PID).</p>
<p>Estimate PID for two source and one target process using different estimators.</p>
<dl class="simple">
<dt>Note:</dt><dd><p>Written for Python 3.4+</p>
</dd>
</dl>
<dl class="py class">
<dt id="idtxl.bivariate_pid.BivariatePID">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.bivariate_pid.</span></code><code class="sig-name descname"><span class="pre">BivariatePID</span></code><a class="reference internal" href="_modules/idtxl/bivariate_pid.html#BivariatePID"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.bivariate_pid.BivariatePID" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.single_process_analysis.SingleProcessAnalysis" title="idtxl.single_process_analysis.SingleProcessAnalysis"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.single_process_analysis.SingleProcessAnalysis</span></code></a></p>
<p>Perform partial information decomposition for individual processes.</p>
<p>Perform partial information decomposition (PID) for two source processes
and one target process in the network. Estimate unique, shared, and
synergistic information in the two sources about the target. Call
analyse_network() on the whole network or a set of nodes or call
analyse_single_target() to estimate PID for a single process. See
docstrings of the two functions for more information.</p>
<p>References:</p>
<ul class="simple">
<li><p>Williams, P. L., &amp; Beer, R. D. (2010). Nonnegative Decomposition of
Multivariate Information, 1–14. Retrieved from
<a class="reference external" href="http://arxiv.org/abs/1004.2515">http://arxiv.org/abs/1004.2515</a></p></li>
<li><p>Bertschinger, N., Rauh, J., Olbrich, E., Jost, J., &amp; Ay, N. (2014).
Quantifying Unique Information. Entropy, 16(4), 2161–2183.
<a class="reference external" href="http://doi.org/10.3390/e16042161">http://doi.org/10.3390/e16042161</a></p></li>
</ul>
<dl class="simple">
<dt>Attributes:</dt><dd><dl class="simple">
<dt>target<span class="classifier">int</span></dt><dd><p>index of target process</p>
</dd>
<dt>sources<span class="classifier">array type</span></dt><dd><p>pair of indices of source processes</p>
</dd>
<dt>settings<span class="classifier">dict</span></dt><dd><p>analysis settings</p>
</dd>
<dt>results<span class="classifier">dict</span></dt><dd><p>estimated PID</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="idtxl.bivariate_pid.BivariatePID.analyse_network">
<code class="sig-name descname"><span class="pre">analyse_network</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sources</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/bivariate_pid.html#BivariatePID.analyse_network"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.bivariate_pid.BivariatePID.analyse_network" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate partial information decomposition for network nodes.</p>
<p>Estimate partial information decomposition (PID) for multiple nodes in
the network.</p>
<dl class="simple">
<dt>Note:</dt><dd><p>For a detailed description of the algorithm and settings see
documentation of the analyse_single_target() method and
references in the class docstring.</p>
</dd>
</dl>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">alph</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">alph</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">alph</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)),</span> <span class="s1">&#39;ps&#39;</span><span class="p">,</span> <span class="n">normalise</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;lags_pid&#39;</span><span class="p">:</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;alpha&#39;</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;alph_s1&#39;</span><span class="p">:</span> <span class="n">alph</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;alph_s2&#39;</span><span class="p">:</span> <span class="n">alph</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;alph_t&#39;</span><span class="p">:</span> <span class="n">alph</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;max_unsuc_swaps_row_parm&#39;</span><span class="p">:</span> <span class="mi">60</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;num_reps&#39;</span><span class="p">:</span> <span class="mi">63</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;max_iters&#39;</span><span class="p">:</span> <span class="mi">1000</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;pid_estimator&#39;</span><span class="p">:</span> <span class="s1">&#39;SydneyPID&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">targets</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pid_analysis</span> <span class="o">=</span> <span class="n">BivariatePID</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">pid_analysis</span><span class="o">.</span><span class="n">analyse_network</span><span class="p">(</span><span class="n">settings</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">targets</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                       <span class="n">sources</span><span class="p">)</span>
</pre></div>
</div>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>parameters for estimation and statistical testing, see
documentation of analyse_single_target() for details, can
contain</p>
<ul class="simple">
<li><p>lags_pid : list of lists of ints [optional] - lags in samples
between sources and target (default=[[1, 1], [1, 1] …])</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data for analysis</p>
</dd>
<dt>targets<span class="classifier">list of int</span></dt><dd><p>index of target processes</p>
</dd>
<dt>sources<span class="classifier">list of lists</span></dt><dd><p>indices of the two source processes for each target, e.g.,
[[0, 2], [1, 0]], must have the same length as targets</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>ResultsPID instance</dt><dd><p>results of network inference, see documentation of
ResultsPID()</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.bivariate_pid.BivariatePID.analyse_single_target">
<code class="sig-name descname"><span class="pre">analyse_single_target</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sources</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/bivariate_pid.html#BivariatePID.analyse_single_target"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.bivariate_pid.BivariatePID.analyse_single_target" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate partial information decomposition for a network node.</p>
<p>Estimate partial information decomposition (PID) for a target node in
the network.</p>
<dl class="simple">
<dt>Note:</dt><dd><p>For a description of the algorithm and the method see references in
the class and estimator docstrings.</p>
</dd>
</dl>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">alph</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">alph</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">alph</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)),</span> <span class="s1">&#39;ps&#39;</span><span class="p">,</span> <span class="n">normalise</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;alpha&#39;</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;alph_s1&#39;</span><span class="p">:</span> <span class="n">alph</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;alph_s2&#39;</span><span class="p">:</span> <span class="n">alph</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;alph_t&#39;</span><span class="p">:</span> <span class="n">alph</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;max_unsuc_swaps_row_parm&#39;</span><span class="p">:</span> <span class="mi">60</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;num_reps&#39;</span><span class="p">:</span> <span class="mi">63</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;max_iters&#39;</span><span class="p">:</span> <span class="mi">1000</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;pid_calc_name&#39;</span><span class="p">:</span> <span class="s1">&#39;SydneyPID&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;lags_pid&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pid_analysis</span> <span class="o">=</span> <span class="n">BivariatePID</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">pid_analysis</span><span class="o">.</span><span class="n">analyse_single_target</span><span class="p">(</span><span class="n">settings</span><span class="o">=</span><span class="n">settings</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                             <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                             <span class="n">target</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                             <span class="n">sources</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
<p>Args: settings : dict parameters for estimator use and statistics:</p>
<blockquote>
<div><blockquote>
<div><ul class="simple">
<li><p>pid_estimator : str - estimator to be used for PID estimation
(for estimator settings see the documentation in the
estimators_pid modules)</p></li>
<li><p>lags_pid : list of ints [optional] - lags in samples between
sources and target (default=[1, 1])</p></li>
<li><p>verbose : bool [optional] - toggle console output
(default=True)</p></li>
</ul>
</div></blockquote>
<dl class="simple">
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data for analysis</p>
</dd>
<dt>target<span class="classifier">int</span></dt><dd><p>index of target processes</p>
</dd>
<dt>sources<span class="classifier">list of ints</span></dt><dd><p>indices of the two source processes for the target</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Returns: ResultsPID instance results of</dt><dd><p>network inference, see documentation of
ResultsPID()</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-idtxl.multivariate_te">
<span id="idtxl-multivariate-te-module"></span><h2>idtxl.multivariate_te module<a class="headerlink" href="#module-idtxl.multivariate_te" title="Permalink to this headline">¶</a></h2>
<p>Perform network inference using multivarate transfer entropy.</p>
<p>Estimate multivariate transfer entropy (TE) for network inference using a
greedy approach with maximum statistics to generate a non-uniform embedding
(Faes, 2011; Lizier, 2012).</p>
<dl class="simple">
<dt>Note:</dt><dd><p>Written for Python 3.4+</p>
</dd>
</dl>
<dl class="py class">
<dt id="idtxl.multivariate_te.MultivariateTE">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.multivariate_te.</span></code><code class="sig-name descname"><span class="pre">MultivariateTE</span></code><a class="reference internal" href="_modules/idtxl/multivariate_te.html#MultivariateTE"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.multivariate_te.MultivariateTE" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.network_inference.NetworkInferenceTE" title="idtxl.network_inference.NetworkInferenceTE"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.network_inference.NetworkInferenceTE</span></code></a>, <a class="reference internal" href="#idtxl.network_inference.NetworkInferenceMultivariate" title="idtxl.network_inference.NetworkInferenceMultivariate"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.network_inference.NetworkInferenceMultivariate</span></code></a></p>
<p>Perform network inference using multivariate transfer entropy.</p>
<p>Perform network inference using multivariate transfer entropy (TE). To
perform network inference call analyse_network() on the whole network or a
set of nodes or call analyse_single_target() to estimate TE for a single
target. See docstrings of the two functions for more information.</p>
<p>References:</p>
<ul class="simple">
<li><p>Schreiber, T. (2000). Measuring Information Transfer. Phys Rev Lett,
85(2), 461–464. <a class="reference external" href="http://doi.org/10.1103/PhysRevLett.85.461">http://doi.org/10.1103/PhysRevLett.85.461</a></p></li>
<li><p>Vicente, R., Wibral, M., Lindner, M., &amp; Pipa, G. (2011). Transfer
entropy-a model-free measure of effective connectivity for the
neurosciences. J Comp Neurosci, 30(1), 45–67.
<a class="reference external" href="http://doi.org/10.1007/s10827-010-0262-3">http://doi.org/10.1007/s10827-010-0262-3</a></p></li>
<li><p>Lizier, J. T., &amp; Rubinov, M. (2012). Multivariate construction of
effective computational networks from observational data. Max Planck
Institute: Preprint. Retrieved from
<a class="reference external" href="http://www.mis.mpg.de/preprints/2012/preprint2012_25.pdf">http://www.mis.mpg.de/preprints/2012/preprint2012_25.pdf</a></p></li>
<li><p>Faes, L., Nollo, G., &amp; Porta, A. (2011). Information-based detection
of nonlinear Granger causality in multivariate processes via a
nonuniform embedding technique. Phys Rev E, 83, 1–15.
<a class="reference external" href="http://doi.org/10.1103/PhysRevE.83.051112">http://doi.org/10.1103/PhysRevE.83.051112</a></p></li>
</ul>
<dl class="simple">
<dt>Attributes:</dt><dd><dl class="simple">
<dt>source_set<span class="classifier">list</span></dt><dd><p>indices of source processes tested for their influence on the
target</p>
</dd>
<dt>target<span class="classifier">list</span></dt><dd><p>index of target process</p>
</dd>
<dt>settings<span class="classifier">dict</span></dt><dd><p>analysis settings</p>
</dd>
<dt>current_value<span class="classifier">tuple</span></dt><dd><p>index of the current value in TE estimation, (idx process,
idx sample)</p>
</dd>
<dt>selected_vars_full<span class="classifier">list of tuples</span></dt><dd><p>samples in the full conditional set, (idx process, idx sample)</p>
</dd>
<dt>selected_vars_sources<span class="classifier">list of tuples</span></dt><dd><p>source samples in the conditional set, (idx process, idx sample)</p>
</dd>
<dt>selected_vars_target<span class="classifier">list of tuples</span></dt><dd><p>target samples in the conditional set, (idx process, idx sample)</p>
</dd>
<dt>pvalue_omnibus<span class="classifier">float</span></dt><dd><p>p-value of the omnibus test</p>
</dd>
<dt>pvalues_sign_sources<span class="classifier">numpy array</span></dt><dd><p>array of p-values for TE from individual sources to the target</p>
</dd>
<dt>statistic_omnibus<span class="classifier">float</span></dt><dd><p>joint TE from all sources to the target</p>
</dd>
<dt>statistic_sign_sources<span class="classifier">numpy array</span></dt><dd><p>raw TE values from individual sources to the target</p>
</dd>
<dt>sign_ominbus<span class="classifier">bool</span></dt><dd><p>statistical significance of the over-all TE</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="idtxl.multivariate_te.MultivariateTE.analyse_network">
<code class="sig-name descname"><span class="pre">analyse_network</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sources</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/multivariate_te.html#MultivariateTE.analyse_network"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.multivariate_te.MultivariateTE.analyse_network" title="Permalink to this definition">¶</a></dt>
<dd><p>Find multivariate transfer entropy between all nodes in the network.</p>
<p>Estimate multivariate transfer entropy (TE) between all nodes in the
network or between selected sources and targets.</p>
<dl>
<dt>Note:</dt><dd><p>For a detailed description of the algorithm and settings see
documentation of the analyse_single_target() method and references
in the class docstring.</p>
</dd>
<dt>Example:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Data</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">generate_mute_data</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;cmi_estimator&#39;</span><span class="p">:</span>  <span class="s1">&#39;JidtKraskovCMI&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_min_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_omnibus&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_seq&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;max_lag_sources&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;min_lag_sources&#39;</span><span class="p">:</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">network_analysis</span> <span class="o">=</span> <span class="n">MultivariateTE</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">network_analysis</span><span class="o">.</span><span class="n">analyse_network</span><span class="p">(</span><span class="n">settings</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
</dd>
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>parameters for estimation and statistical testing, see
documentation of analyse_single_target() for details, settings
can further contain</p>
<ul class="simple">
<li><p>verbose : bool [optional] - toggle console output
(default=True)</p></li>
<li><p>fdr_correction : bool [optional] - correct results on the
network level, see documentation of stats.network_fdr() for
details (default=True)</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data for analysis</p>
</dd>
<dt>targets<span class="classifier">list of int | ‘all’ [optional]</span></dt><dd><p>index of target processes (default=’all’)</p>
</dd>
<dt>sources<span class="classifier">list of int | list of list | ‘all’ [optional]</span></dt><dd><p>indices of source processes for each target (default=’all’);
if ‘all’, all network nodes excluding the target node are
considered as potential sources and tested;
if list of int, the source specified by each int is tested as
a potential source for the target with the same index or a
single target;
if list of list, sources specified in each inner list are
tested for the target with the same index</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>ResultsNetworkInference instance</dt><dd><p>results of network inference, see documentation of
ResultsNetworkInference()</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.multivariate_te.MultivariateTE.analyse_single_target">
<code class="sig-name descname"><span class="pre">analyse_single_target</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sources</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/multivariate_te.html#MultivariateTE.analyse_single_target"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.multivariate_te.MultivariateTE.analyse_single_target" title="Permalink to this definition">¶</a></dt>
<dd><p>Find multivariate transfer entropy between sources and a target.</p>
<p>Find multivariate transfer entropy (TE) between all source processes
and the target process. Uses multivariate, non-uniform embedding found
through information maximisation. Multivariate TE is calculated in four
steps:</p>
<ol class="arabic simple">
<li><p>find all relevant variables in the target processes’ own past, by
iteratively adding candidate variables that have significant
conditional mutual information (CMI) with the current value
(conditional on all variables that were added previously)</p></li>
<li><p>find all relevant variables in the source processes’ pasts (again
by finding all candidates with significant CMI)</p></li>
<li><p>prune the final conditional set by testing the CMI between each
variable in the final set and the current value, conditional on all
other variables in the final set</p></li>
<li><p>statistics on the final set of sources (test for over-all transfer
between the final conditional set and the current value, and for
significant transfer of all individual variables in the set)</p></li>
</ol>
<dl class="simple">
<dt>Note:</dt><dd><p>For a further description of the algorithm see references in the
class docstring.</p>
</dd>
</dl>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Data</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">generate_mute_data</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;cmi_estimator&#39;</span><span class="p">:</span>  <span class="s1">&#39;JidtKraskovCMI&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_min_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_omnibus&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_seq&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;max_lag_sources&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;min_lag_sources&#39;</span><span class="p">:</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">target</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">network_analysis</span> <span class="o">=</span> <span class="n">MultivariateTE</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">network_analysis</span><span class="o">.</span><span class="n">analyse_single_target</span><span class="p">(</span><span class="n">settings</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                                 <span class="n">data</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                                 <span class="n">sources</span><span class="p">)</span>
</pre></div>
</div>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>parameters for estimation and statistical testing:</p>
<ul class="simple">
<li><p>cmi_estimator : str - estimator to be used for CMI
calculation (for estimator settings see the documentation in
the estimators_* modules)</p></li>
<li><p>max_lag_sources : int - maximum temporal search depth for
candidates in the sources’ past in samples</p></li>
<li><p>min_lag_sources : int - minimum temporal search depth for
candidates in the sources’ past in samples</p></li>
<li><p>max_lag_target : int [optional] - maximum temporal search
depth for candidates in the target’s past in samples
(default=same as max_lag_sources)</p></li>
<li><p>tau_sources : int [optional] - spacing between candidates in
the sources’ past in samples (default=1)</p></li>
<li><p>tau_target : int [optional] - spacing between candidates in
the target’s past in samples (default=1)</p></li>
<li><p>n_perm_* : int [optional] - number of permutations, where *
can be ‘max_stat’, ‘min_stat’, ‘omnibus’, and ‘max_seq’
(default=500)</p></li>
<li><p>alpha_* : float [optional] - critical alpha level for
statistical significance, where * can be ‘max_stats’,
‘min_stats’, ‘omnibus’, and ‘max_seq’ (default=0.05)</p></li>
<li><p>add_conditionals : list of tuples | str [optional] - force
the estimator to add these conditionals when estimating TE;
can either be a list of variables, where each variable is
described as (idx process, lag wrt to current value) or can
be a string: ‘faes’ for Faes-Method (see references)</p></li>
<li><p>permute_in_time : bool [optional] - force surrogate
creation by shuffling realisations in time instead of
shuffling replications; see documentation of
Data.permute_samples() for further settings (default=False)</p></li>
<li><p>verbose : bool [optional] - toggle console output
(default=True)</p></li>
<li><p>write_ckp : bool [optional] - enable checkpointing, writes
analysis state to disk every time a variable is selected;
resume crashed analysis using
network_analysis.resume_checkpoint() (default=False)</p></li>
<li><p>filename_ckp : str [optional] - checkpoint file name (without
extension) (default=’./idtxl_checkpoint’)</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data for analysis</p>
</dd>
<dt>target<span class="classifier">int</span></dt><dd><p>index of target process</p>
</dd>
<dt>sources<span class="classifier">list of int | int | ‘all’ [optional]</span></dt><dd><p>single index or list of indices of source processes
(default=’all’), if ‘all’, all network nodes excluding the
target node are considered as potential sources</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>ResultsNetworkInference instance</dt><dd><p>results of network inference, see documentation of
ResultsNetworkInference()</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.multivariate_te.MultivariateTE.getit">
<code class="sig-name descname"><span class="pre">getit</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/multivariate_te.html#MultivariateTE.getit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.multivariate_te.MultivariateTE.getit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-idtxl.multivariate_mi">
<span id="idtxl-multivariate-mi-module"></span><h2>idtxl.multivariate_mi module<a class="headerlink" href="#module-idtxl.multivariate_mi" title="Permalink to this headline">¶</a></h2>
<p>Perform network inference using multivarate mutual information.</p>
<p>Estimate multivariate mutual information (MI) for network inference using a
greedy approach with maximum statistics to generate a non-uniform embedding
(Faes, 2011; Lizier, 2012).</p>
<dl class="simple">
<dt>Note:</dt><dd><p>Written for Python 3.4+</p>
</dd>
</dl>
<dl class="py class">
<dt id="idtxl.multivariate_mi.MultivariateMI">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.multivariate_mi.</span></code><code class="sig-name descname"><span class="pre">MultivariateMI</span></code><a class="reference internal" href="_modules/idtxl/multivariate_mi.html#MultivariateMI"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.multivariate_mi.MultivariateMI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.network_inference.NetworkInferenceMI" title="idtxl.network_inference.NetworkInferenceMI"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.network_inference.NetworkInferenceMI</span></code></a>, <a class="reference internal" href="#idtxl.network_inference.NetworkInferenceMultivariate" title="idtxl.network_inference.NetworkInferenceMultivariate"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.network_inference.NetworkInferenceMultivariate</span></code></a></p>
<p>Perform network inference using multivariate mutual information.</p>
<p>Perform network inference using multivariate mutual information (MI). To
perform network inference call analyse_network() on the whole network or a
set of nodes or call analyse_single_target() to estimate MI for a single
target. See docstrings of the two functions for more information.</p>
<p>References:</p>
<ul class="simple">
<li><p>Lizier, J. T., &amp; Rubinov, M. (2012). Multivariate construction of
effective computational networks from observational data. Max Planck
Institute: Preprint. Retrieved from
<a class="reference external" href="http://www.mis.mpg.de/preprints/2012/preprint2012_25.pdf">http://www.mis.mpg.de/preprints/2012/preprint2012_25.pdf</a></p></li>
<li><p>Faes, L., Nollo, G., &amp; Porta, A. (2011). Information-based detection
of nonlinear Granger causality in multivariate processes via a
nonuniform embedding technique. Phys Rev E, 83, 1–15.
<a class="reference external" href="http://doi.org/10.1103/PhysRevE.83.051112">http://doi.org/10.1103/PhysRevE.83.051112</a></p></li>
</ul>
<dl class="simple">
<dt>Attributes:</dt><dd><dl class="simple">
<dt>source_set<span class="classifier">list</span></dt><dd><p>indices of source processes tested for their influence on the
target</p>
</dd>
<dt>target<span class="classifier">list</span></dt><dd><p>index of target process</p>
</dd>
<dt>settings<span class="classifier">dict</span></dt><dd><p>analysis settings</p>
</dd>
<dt>current_value<span class="classifier">tuple</span></dt><dd><p>index of the current value in MI estimation, (idx process,
idx sample)</p>
</dd>
<dt>selected_vars_full<span class="classifier">list of tuples</span></dt><dd><p>samples in the full conditional set, (idx process, idx sample)</p>
</dd>
<dt>selected_vars_sources<span class="classifier">list of tuples</span></dt><dd><p>source samples in the conditional set, (idx process, idx sample)</p>
</dd>
<dt>pvalue_omnibus<span class="classifier">float</span></dt><dd><p>p-value of the omnibus test</p>
</dd>
<dt>pvalues_sign_sources<span class="classifier">numpy array</span></dt><dd><p>array of p-values for MI from individual sources to the target</p>
</dd>
<dt>mi_omnibus<span class="classifier">float</span></dt><dd><p>joint MI from all sources to the target</p>
</dd>
<dt>mi_sign_sources<span class="classifier">numpy array</span></dt><dd><p>raw MI values from individual sources to the target</p>
</dd>
<dt>sign_ominbus<span class="classifier">bool</span></dt><dd><p>statistical significance of the over-all MI</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="idtxl.multivariate_mi.MultivariateMI.analyse_network">
<code class="sig-name descname"><span class="pre">analyse_network</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sources</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/multivariate_mi.html#MultivariateMI.analyse_network"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.multivariate_mi.MultivariateMI.analyse_network" title="Permalink to this definition">¶</a></dt>
<dd><p>Find multivariate mutual information between nodes in the network.</p>
<p>Estimate multivariate mutual information (MI) between all nodes in the
network or between selected sources and targets.</p>
<dl class="simple">
<dt>Note:</dt><dd><p>For a detailed description of the algorithm and settings see
documentation of the analyse_single_target() method and references
in the class docstring.</p>
</dd>
</dl>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Data</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">generate_mute_data</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># The algorithm uses a conditional mutual information to</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># construct a non-uniform embedding, hence a CMI- not MI-</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># estimator has to be specified:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;cmi_estimator&#39;</span><span class="p">:</span>  <span class="s1">&#39;JidtKraskovCMI&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_min_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_omnibus&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_seq&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;max_lag_sources&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;min_lag_sources&#39;</span><span class="p">:</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">network_analysis</span> <span class="o">=</span> <span class="n">MultivariateMI</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">network_analysis</span><span class="o">.</span><span class="n">analyse_network</span><span class="p">(</span><span class="n">settings</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>parameters for estimation and statistical testing, see
documentation of analyse_single_target() for details, settings
can further contain</p>
<ul class="simple">
<li><p>verbose : bool [optional] - toggle console output
(default=True)</p></li>
<li><p>fdr_correction : bool [optional] - correct results on the
network level, see documentation of stats.network_fdr() for
details (default=True)</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data for analysis</p>
</dd>
<dt>targets<span class="classifier">list of int | ‘all’ [optional]</span></dt><dd><p>index of target processes (default=’all’)</p>
</dd>
<dt>sources<span class="classifier">list of int | list of list | ‘all’ [optional]</span></dt><dd><p>indices of source processes for each target (default=’all’);
if ‘all’, all network nodes excluding the target node are
considered as potential sources and tested;
if list of int, the source specified by each int is tested as
a potential source for the target with the same index or a
single target;
if list of list, sources specified in each inner list are
tested for the target with the same index</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>dict</dt><dd><p>results for each target, see documentation of
analyse_single_target(); results FDR-corrected, see
documentation of stats.network_fdr()</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.multivariate_mi.MultivariateMI.analyse_single_target">
<code class="sig-name descname"><span class="pre">analyse_single_target</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sources</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/multivariate_mi.html#MultivariateMI.analyse_single_target"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.multivariate_mi.MultivariateMI.analyse_single_target" title="Permalink to this definition">¶</a></dt>
<dd><p>Find multivariate mutual information between sources and a target.</p>
<p>Find multivariate mutual information (MI) between all source processes
and the target process. Uses multivariate, non-uniform embedding found
through information maximisation .</p>
<p>Multivariate MI is calculated in four steps (see Lizier and Faes for
details):</p>
<dl class="simple">
<dt>Note:</dt><dd><p>For a further description of the algorithm see references in the
class docstring.</p>
</dd>
</dl>
<ol class="arabic simple">
<li><p>Find all relevant samples in the source processes’ past, by
iteratively adding candidate samples that have significant
conditional mutual information (CMI) with the current value
(conditional on all samples that were added previously)</p></li>
<li><p>Prune the final conditional set by testing the CMI between each
sample in the final set and the current value, conditional on all
other samples in the final set</p></li>
<li><p>Statistics on the final set of sources (test for over-all transfer
between the final conditional set and the current value, and for
significant transfer of all individual samples in the set)</p></li>
</ol>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Data</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">generate_mute_data</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># The algorithm uses a conditional mutual information to</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># construct a non-uniform embedding, hence a CMI- not MI-</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># estimator has to be specified:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;cmi_estimator&#39;</span><span class="p">:</span>  <span class="s1">&#39;JidtKraskovCMI&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_min_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_omnibus&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_seq&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;max_lag_sources&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;min_lag_sources&#39;</span><span class="p">:</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">target</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">network_analysis</span> <span class="o">=</span> <span class="n">MultivariateMI</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">network_analysis</span><span class="o">.</span><span class="n">analyse_single_target</span><span class="p">(</span><span class="n">settings</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                                 <span class="n">data</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                                 <span class="n">sources</span><span class="p">)</span>
</pre></div>
</div>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>parameters for estimation and statistical testing:</p>
<ul class="simple">
<li><p>cmi_estimator : str - estimator to be used for CMI
calculation (for estimator settings see the documentation in
the estimators_* modules)</p></li>
<li><p>max_lag_sources : int - maximum temporal search depth for
candidates in the sources’ past in samples</p></li>
<li><p>min_lag_sources : int - minimum temporal search depth for
candidates in the sources’ past in samples</p></li>
<li><p>tau_sources : int [optional] - spacing between candidates in
the sources’ past in samples (default=1)</p></li>
<li><p>n_perm_* : int [optional] - number of permutations, where *
can be ‘max_stat’, ‘min_stat’, ‘omnibus’, and ‘max_seq’
(default=500)</p></li>
<li><p>alpha_* : float [optional] - critical alpha level for
statistical significance, where * can be ‘max_stats’,
‘min_stats’, ‘omnibus’, and ‘max_seq’ (default=0.05)</p></li>
<li><p>add_conditionals : list of tuples | str [optional] - force
the estimator to add these conditionals when estimating MI;
can either be a list of variables, where each variable is
described as (idx process, lag wrt to current value) or can
be a string: ‘faes’ for Faes-Method (see references)</p></li>
<li><p>permute_in_time : bool [optional] - force surrogate
creation by shuffling realisations in time instead of
shuffling replications; see documentation of
Data.permute_samples() for further settings (default=False)</p></li>
<li><p>verbose : bool [optional] - toggle console output
(default=True)</p></li>
<li><p>write_ckp : bool [optional] - enable checkpointing, writes
analysis state to disk every time a variable is selected;
resume crashed analysis using
network_analysis.resume_checkpoint() (default=False)</p></li>
<li><p>filename_ckp : str [optional] - checkpoint file name (without
extension) (default=’./idtxl_checkpoint’)</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data for analysis</p>
</dd>
<dt>target<span class="classifier">int</span></dt><dd><p>index of target process</p>
</dd>
<dt>sources<span class="classifier">list of int | int | ‘all’ [optional]</span></dt><dd><p>single index or list of indices of source processes
(default=’all’), if ‘all’, all network nodes excluding the
target node are considered as potential sources</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>dict</dt><dd><p>results consisting of sets of selected variables as (full set,
variables from the sources’ past), pvalues and MI for each
selected variable, the current value for this analysis, results
for omnibus test (joint MI between all selected source
variables and the target, omnibus MI, p-value, and
significance); NOTE that all variables are listed as tuples
(process, lag wrt. current value)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-idtxl.multivariate_pid">
<span id="idtxl-multivariate-pid-module"></span><h2>idtxl.multivariate_pid module<a class="headerlink" href="#module-idtxl.multivariate_pid" title="Permalink to this headline">¶</a></h2>
<p>Estimate partial information decomposition (PID).</p>
<p>Estimate PID for multiple sources (up to 4 sources) and one target process
using SxPID estimator.</p>
<dl class="simple">
<dt>Note:</dt><dd><p>Written for Python 3.4+</p>
</dd>
</dl>
<dl class="py class">
<dt id="idtxl.multivariate_pid.MultivariatePID">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.multivariate_pid.</span></code><code class="sig-name descname"><span class="pre">MultivariatePID</span></code><a class="reference internal" href="_modules/idtxl/multivariate_pid.html#MultivariatePID"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.multivariate_pid.MultivariatePID" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.single_process_analysis.SingleProcessAnalysis" title="idtxl.single_process_analysis.SingleProcessAnalysis"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.single_process_analysis.SingleProcessAnalysis</span></code></a></p>
<p>Perform partial information decomposition for individual processes.</p>
<p>Perform partial information decomposition (PID) for multiple source
processes (up to 4 sources) and a target process in the network.
Estimate unique, shared, and synergistic information in the multiple
sources about the target. Call analyse_network() on the whole network
or a set of nodes or call analyse_single_target() to estimate PID for
a single process. See docstrings of the two functions for more information.</p>
<p>References:</p>
<ul class="simple">
<li><p>Williams, P. L., &amp; Beer, R. D. (2010). Nonnegative Decomposition of
Multivariate Information, 1–14. Retrieved from
<a class="reference external" href="http://arxiv.org/abs/1004.2515">http://arxiv.org/abs/1004.2515</a></p></li>
<li><p>Makkeh, A. &amp; Gutknecht, A. &amp; Wibral, M. (2020). A Differentiable measure
for shared information. 1- 27 Retrieved from
<a class="reference external" href="http://arxiv.org/abs/2002.03356">http://arxiv.org/abs/2002.03356</a></p></li>
</ul>
<dl class="simple">
<dt>Attributes:</dt><dd><dl class="simple">
<dt>target<span class="classifier">int</span></dt><dd><p>index of target process</p>
</dd>
<dt>sources<span class="classifier">array type</span></dt><dd><p>multiple of indices of source processes</p>
</dd>
<dt>settings<span class="classifier">dict</span></dt><dd><p>analysis settings</p>
</dd>
<dt>results<span class="classifier">dict</span></dt><dd><p>estimated PID</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="idtxl.multivariate_pid.MultivariatePID.analyse_network">
<code class="sig-name descname"><span class="pre">analyse_network</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sources</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/multivariate_pid.html#MultivariatePID.analyse_network"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.multivariate_pid.MultivariatePID.analyse_network" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate partial information decomposition for network nodes.</p>
<p>Estimate, for multiple nodes (target processes), the partial
information decomposition (PID) for multiple source processes
(up to 4 sources) and each of these target processes
in the network.</p>
<dl class="simple">
<dt>Note:</dt><dd><p>For a detailed description of the algorithm and settings see
documentation of the analyse_single_target() method and
references in the class docstring.</p>
</dd>
</dl>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">alph</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">alph</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">alph</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">alph</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">target1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">target</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">target1</span><span class="p">,</span> <span class="n">s3</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">s3</span><span class="p">,</span> <span class="n">target</span><span class="p">)),</span> <span class="s1">&#39;ps&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">normalise</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;lags_pid&#39;</span><span class="p">:</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">]],</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;verbose&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;pid_estimator&#39;</span><span class="p">:</span> <span class="s1">&#39;SxPID&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">targets</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pid_analysis</span> <span class="o">=</span> <span class="n">MultivariatePID</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">pid_analysis</span><span class="o">.</span><span class="n">analyse_network</span><span class="p">(</span><span class="n">settings</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">targets</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                       <span class="n">sources</span><span class="p">)</span>
</pre></div>
</div>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>parameters for estimation and statistical testing, see
documentation of analyse_single_target() for details, can
contain</p>
<ul class="simple">
<li><p>lags_pid : list of lists of ints [optional] - lags in samples
between sources and target
(default=[[1, 1, …, 1], [1, 1, …, 1], …])</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data for analysis</p>
</dd>
<dt>targets<span class="classifier">list of int</span></dt><dd><p>index of target processes</p>
</dd>
<dt>sources<span class="classifier">list of lists</span></dt><dd><p>indices of the multiple source processes for each target, e.g.,
[[0, 1, 2], [1, 0, 3]], all must lists be of the same lenght and
list of lists must have the same length as targets</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>ResultsMultivariatePID instance</dt><dd><p>results of network inference, see documentation of
ResultsMultivariatePID()</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.multivariate_pid.MultivariatePID.analyse_single_target">
<code class="sig-name descname"><span class="pre">analyse_single_target</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sources</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/multivariate_pid.html#MultivariatePID.analyse_single_target"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.multivariate_pid.MultivariatePID.analyse_single_target" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate partial information decomposition for a network node.</p>
<p>Estimate partial information decomposition (PID) for multiple source
processes (up to 4 sources) and a target process in the network.</p>
<dl class="simple">
<dt>Note:</dt><dd><p>For a description of the algorithm and the method see references in
the class and estimator docstrings.</p>
</dd>
</dl>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">alph</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">alph</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">alph</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">alph</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">target1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">target</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">target1</span><span class="p">,</span> <span class="n">s3</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">s3</span><span class="p">,</span> <span class="n">target</span><span class="p">)),</span> <span class="s1">&#39;ps&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">normalise</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;verbose&#39;</span> <span class="p">:</span> <span class="n">false</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;pid_estimator&#39;</span><span class="p">:</span> <span class="s1">&#39;SxPID&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;lags_pid&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pid_analysis</span> <span class="o">=</span> <span class="n">MultivariatePID</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">pid_analysis</span><span class="o">.</span><span class="n">analyse_single_target</span><span class="p">(</span><span class="n">settings</span><span class="o">=</span><span class="n">settings</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                             <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                             <span class="n">target</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                             <span class="n">sources</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
</pre></div>
</div>
<p>Args: settings : dict parameters for estimator use and statistics:</p>
<blockquote>
<div><blockquote>
<div><ul class="simple">
<li><p>pid_estimator : str - estimator to be used for PID estimation
(for estimator settings see the documentation in the
estimators_pid modules)</p></li>
<li><p>lags_pid : list of ints [optional] - lags in samples between
sources and target (default=[1, 1, …, 1])</p></li>
<li><p>verbose : bool [optional] - toggle console output
(default=True)</p></li>
</ul>
</div></blockquote>
<dl class="simple">
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data for analysis</p>
</dd>
<dt>target<span class="classifier">int</span></dt><dd><p>index of target processes</p>
</dd>
<dt>sources<span class="classifier">list of ints</span></dt><dd><p>indices of the multiple source processes for the target</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Returns: ResultsMultivariatePID instance results of</dt><dd><p>network inference, see documentation of
ResultsPID()</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-idtxl.active_information_storage">
<span id="idtxl-active-information-storage-module"></span><h2>idtxl.active_information_storage module<a class="headerlink" href="#module-idtxl.active_information_storage" title="Permalink to this headline">¶</a></h2>
<p>Analysis of AIS in a network of processes.</p>
<p>Analysis of active information storage (AIS) in individual processes of a
network. The algorithm uses non-uniform embedding as described in Faes (2011).</p>
<dl class="simple">
<dt>Note:</dt><dd><p>Written for Python 3.4+</p>
</dd>
</dl>
<dl class="py class">
<dt id="idtxl.active_information_storage.ActiveInformationStorage">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.active_information_storage.</span></code><code class="sig-name descname"><span class="pre">ActiveInformationStorage</span></code><a class="reference internal" href="_modules/idtxl/active_information_storage.html#ActiveInformationStorage"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.active_information_storage.ActiveInformationStorage" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.single_process_analysis.SingleProcessAnalysis" title="idtxl.single_process_analysis.SingleProcessAnalysis"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.single_process_analysis.SingleProcessAnalysis</span></code></a></p>
<p>Estimate active information storage in individual processes.</p>
<p>Estimate active information storage (AIS) in individual processes of the
network. To perform AIS estimation call analyse_network() on the whole
network or a set of nodes or call analyse_single_process() to estimate
AIS for a single process. See docstrings of the two functions for more
information.</p>
<p>References:</p>
<ul class="simple">
<li><p>Lizier, J. T., Prokopenko, M., &amp; Zomaya, A. Y. (2012). Local measures of
information storage in complex distributed computation. Inform Sci, 208,
39–54. <a class="reference external" href="http://doi.org/10.1016/j.ins.2012.04.016">http://doi.org/10.1016/j.ins.2012.04.016</a></p></li>
<li><p>Wibral, M., Lizier, J. T., Vögler, S., Priesemann, V., &amp; Galuske, R.
(2014). Local active information storage as a tool to understand
distributed neural information processing. Front Neuroinf, 8, 1.
<a class="reference external" href="http://doi.org/10.3389/fninf.2014.00001">http://doi.org/10.3389/fninf.2014.00001</a></p></li>
<li><p>Faes, L., Nollo, G., &amp; Porta, A. (2011). Information-based detection
of nonlinear Granger causality in multivariate processes via a
nonuniform embedding technique. Phys Rev E, 83, 1–15.
<a class="reference external" href="http://doi.org/10.1103/PhysRevE.83.051112">http://doi.org/10.1103/PhysRevE.83.051112</a></p></li>
</ul>
<dl class="simple">
<dt>Attributes:</dt><dd><dl class="simple">
<dt>process_set<span class="classifier">list</span></dt><dd><p>list with indices of analyzed processes</p>
</dd>
<dt>settings<span class="classifier">dict</span></dt><dd><p>analysis settings</p>
</dd>
<dt>current_value<span class="classifier">tuple</span></dt><dd><p>index of the current value in AIS estimation, (idx process,
idx sample)</p>
</dd>
<dt>selected_vars_full<span class="classifier">list of tuples</span></dt><dd><p>samples in the past state, (idx process, idx sample)</p>
</dd>
<dt>ais<span class="classifier">float</span></dt><dd><p>raw AIS value</p>
</dd>
<dt>sign<span class="classifier">bool</span></dt><dd><p>true if AIS is significant</p>
</dd>
<dt>pvalue: float</dt><dd><p>p-value of AIS</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="idtxl.active_information_storage.ActiveInformationStorage.analyse_network">
<code class="sig-name descname"><span class="pre">analyse_network</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">processes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/active_information_storage.html#ActiveInformationStorage.analyse_network"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.active_information_storage.ActiveInformationStorage.analyse_network" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate active information storage for multiple network processes.</p>
<p>Estimate active information storage for all or a subset of processes in
the network.</p>
<dl class="simple">
<dt>Note:</dt><dd><p>For a detailed description of the algorithm and settings see
documentation of the analyse_single_process() method and
references in the class docstring.</p>
</dd>
</dl>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">Data</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">generate_mute_data</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;cmi_estimator&#39;</span><span class="p">:</span> <span class="s1">&#39;JidtKraskovCMI&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_min_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;max_lag&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;tau&#39;</span><span class="p">:</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">processes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">network_analysis</span> <span class="o">=</span> <span class="n">ActiveInformationStorage</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">network_analysis</span><span class="o">.</span><span class="n">analyse_network</span><span class="p">(</span><span class="n">settings</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                           <span class="n">processes</span><span class="p">)</span>
</pre></div>
</div>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>parameters for estimation and statistical testing, see
documentation of analyse_single_target() for details, settings
can further contain</p>
<ul class="simple">
<li><p>verbose : bool [optional] - toggle console output
(default=True)</p></li>
<li><p>fdr_correction : bool [optional] - correct results on the
network level, see documentation of stats.ais_fdr() for
details (default=True)</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data for analysis</p>
</dd>
<dt>processes<span class="classifier">list of int | ‘all’</span></dt><dd><p>index of processes (default=’all’);
if ‘all’, AIS is estimated for all processes;
if list of int, AIS is estimated for processes specified in the
list.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>ResultsSingleProcessAnalysis instance</dt><dd><p>results of network AIS estimation, see documentation of
ResultsSingleProcessAnalysis()</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.active_information_storage.ActiveInformationStorage.analyse_single_process">
<code class="sig-name descname"><span class="pre">analyse_single_process</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">process</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/active_information_storage.html#ActiveInformationStorage.analyse_single_process"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.active_information_storage.ActiveInformationStorage.analyse_single_process" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate active information storage for a single process.</p>
<p>Estimate active information storage for one process in the network.
Uses non-uniform embedding found through information maximisation. This
is done in three steps (see Lizier and Faes for details):</p>
<ol class="arabic simple">
<li><p>Find all relevant samples in the processes’ own past, by
iteratively adding candidate samples that have significant
conditional mutual information (CMI) with the current value
(conditional on all samples that were added previously)</p></li>
<li><p>Prune the final conditional set by testing the CMI between each
sample in the final set and the current value, conditional on all
other samples in the final set</p></li>
<li><p>Calculate AIS using the final set of candidates as the past state
(calculate MI between samples in the past and the current value);
test for statistical significance using a permutation test</p></li>
</ol>
<dl class="simple">
<dt>Note:</dt><dd><p>For a further description of the algorithm see references in the
class docstring.</p>
</dd>
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>parameters for estimator use and statistics:</p>
<ul class="simple">
<li><p>cmi_estimator : str - estimator to be used for CMI and MI
calculation (for estimator settings see the documentation in
the estimators_* modules)</p></li>
<li><p>max_lag : int - maximum temporal search depth for candidates
in the processes’ past in samples</p></li>
<li><p>tau : int [optional] - spacing between candidates in the
sources’ past in samples (default=1)</p></li>
<li><p>n_perm_* : int [optional] - number of permutations, where *
can be ‘max_stat’, ‘min_stat’, ‘mi’ (default=500)</p></li>
<li><p>alpha_* : float [optional] - critical alpha level for
statistical significance, where * can be ‘max_stat’,
‘min_stat’, ‘mi’ (default=0.05)</p></li>
<li><p>add_conditionals : list of tuples | str [optional] - force
the estimator to add these conditionals when estimating TE;
can either be a list of variables, where each variable is
described as (idx process, lag wrt to current value) or can
be a string: ‘faes’ for Faes-Method (see references)</p></li>
<li><p>permute_in_time : bool [optional] - force surrogate creation
by shuffling realisations in time instead of shuffling
replications; see documentation of Data.permute_samples() for
further settings (default=False)</p></li>
<li><p>verbose : bool [optional] - toggle console output
(default=True)</p></li>
<li><p>write_ckp : bool [optional] - enable checkpointing, writes
analysis state to disk every time a variable is selected;
resume crashed analysis using
network_analysis.resume_checkpoint() (default=False)</p></li>
<li><p>filename_ckp : str [optional] - checkpoint file name (without
extension) (default=’./idtxl_checkpoint’)</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data for analysis</p>
</dd>
<dt>process<span class="classifier">int</span></dt><dd><p>index of process</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>ResultsSingleProcessAnalysis instance</dt><dd><p>results of AIS estimation, see documentation of
ResultsSingleProcessAnalysis()</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-idtxl.estimators_jidt">
<span id="idtxl-estimators-jidt-module"></span><h2>idtxl.estimators_jidt module<a class="headerlink" href="#module-idtxl.estimators_jidt" title="Permalink to this headline">¶</a></h2>
<p>Provide JIDT estimators.</p>
<dl class="py class">
<dt id="idtxl.estimators_jidt.JidtDiscrete">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></code><code class="sig-name descname"><span class="pre">JidtDiscrete</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscrete"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscrete" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtEstimator" title="idtxl.estimators_jidt.JidtEstimator"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimators_jidt.JidtEstimator</span></code></a></p>
<p>Abstract class for implementation of discrete JIDT-estimators.</p>
<p>Abstract class for implementation of plug-in JIDT-estimators for discrete
data. Child classes implement estimators for mutual information (MI),
conditional mutual information (CMI), actice information storage (AIS), and
transfer entropy (TE). See parent class for references.</p>
<p>Set common estimation parameters for discrete JIDT-estimators. For usage of
these estimators see documentation for the child classes.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>set estimator parameters:</p>
<ul class="simple">
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
<li><p>discretise_method : str [optional] - if and how to discretise
incoming continuous data, can be ‘max_ent’ for maximum entropy
binning, ‘equal’ for equal size bins, and ‘none’ if no binning is
required (default=’none’)</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>Note:</dt><dd><p>Discrete JIDT estimators require the data’s alphabet size for
instantiation. Hence, opposed to the Kraskov and Gaussian estimators,
the JAVA class is added to the object instance, while for Kraskov/
Gaussian estimators an instance of that class is added (because for the
latter, objects can be instantiated independent of data properties).</p>
</dd>
</dl>
<dl class="py method">
<dt id="idtxl.estimators_jidt.JidtDiscrete.estimate_surrogates_analytic">
<code class="sig-name descname"><span class="pre">estimate_surrogates_analytic</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_perm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscrete.estimate_surrogates_analytic"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscrete.estimate_surrogates_analytic" title="Permalink to this definition">¶</a></dt>
<dd><p>Return estimate of the analytical surrogate distribution.</p>
<p>This method must be implemented because this class’
is_analytic_null_estimator() method returns true.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>n_perms<span class="classifier">int [optional]</span></dt><dd><p>number of permutations (default=200)</p>
</dd>
<dt>data<span class="classifier">numpy arrays</span></dt><dd><p>realisations of random variables required for the calculation
(varies between estimators, e.g. 2 variables for MI, 3 for
CMI). Formatted as per the estimate method for this estimator.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>n_perm surrogates of the average MI/CMI/TE over all samples
under the null hypothesis of no relationship between var1 and
var2 (in the context of conditional)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.estimators_jidt.JidtDiscrete.get_analytic_distribution">
<em class="property"><span class="pre">abstract</span> </em><code class="sig-name descname"><span class="pre">get_analytic_distribution</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscrete.get_analytic_distribution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscrete.get_analytic_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a JIDT AnalyticNullDistribution object.</p>
<p>Required so that our estimate_surrogates_analytic method can use the
common_estimate_surrogates_analytic() method, where data is formatted
as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>data<span class="classifier">numpy arrays</span></dt><dd><p>realisations of random variables required for the calculation
(varies between estimators, e.g. 2 variables for MI, 3 for
CMI). Formatted as per the estimate method for this estimator.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>Java object</dt><dd><p>JIDT calculator that was used here</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.estimators_jidt.JidtDiscrete.is_analytic_null_estimator">
<code class="sig-name descname"><span class="pre">is_analytic_null_estimator</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscrete.is_analytic_null_estimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscrete.is_analytic_null_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate if estimator supports analytic surrogates.</p>
<p>Return true if the estimator implements estimate_surrogates_analytic()
where data is formatted as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="idtxl.estimators_jidt.JidtDiscreteAIS">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></code><code class="sig-name descname"><span class="pre">JidtDiscreteAIS</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteAIS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscreteAIS" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtDiscrete" title="idtxl.estimators_jidt.JidtDiscrete"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimators_jidt.JidtDiscrete</span></code></a></p>
<p>Calculate AIS with JIDT’s discrete-variable implementation.</p>
<p>Calculate the active information storage (AIS) for one process. Call JIDT
via jpype and use the discrete estimator. See parent class for references.</p>
<p>Results are returned in bits.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>set estimator parameters:</p>
<ul class="simple">
<li><p>history : int - number of samples in the target’s past used as
embedding (&gt;= 0)</p></li>
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
<li><p>discretise_method : str [optional] - if and how to discretise
incoming continuous data, can be ‘max_ent’ for maximum entropy
binning, ‘equal’ for equal size bins, and ‘none’ if no binning is
required (default=’none’)</p></li>
<li><p>n_discrete_bins : int [optional] - number of discrete bins/
levels or the base of each dimension of the discrete variables
(default=2). If set, this parameter overwrites/sets alph. (&gt;= 2)</p></li>
<li><p>alph : int [optional] - number of discrete bins/levels for var1
(default=2 , or the value set for n_discrete_bins). (&gt;= 2)</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="idtxl.estimators_jidt.JidtDiscreteAIS.estimate">
<code class="sig-name descname"><span class="pre">estimate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">process</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_calc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteAIS.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscreteAIS.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate active information storage.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>process<span class="classifier">numpy array</span></dt><dd><p>realisations as either a 2D numpy array where array dimensions
represent [realisations x variable dimension] or a 1D array
representing [realisations], array type can be float (requires
discretisation) or int</p>
</dd>
<dt>return_calc<span class="classifier">boolean</span></dt><dd><p>return the calculator used here as well as the numeric
calculated value(s)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>average AIS over all samples or local AIS for individual
samples if ‘local_values’=True</p>
</dd>
<dt>Java object</dt><dd><p>JIDT calculator that was used here. Only returned if
return_calc was set.</p>
</dd>
</dl>
</dd>
<dt>Raises:</dt><dd><dl class="simple">
<dt>ex.JidtOutOfMemoryError</dt><dd><p>Raised when JIDT object cannot be instantiated due to mem error</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.estimators_jidt.JidtDiscreteAIS.get_analytic_distribution">
<code class="sig-name descname"><span class="pre">get_analytic_distribution</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">process</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteAIS.get_analytic_distribution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscreteAIS.get_analytic_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a JIDT AnalyticNullDistribution object.</p>
<p>Required so that our estimate_surrogates_analytic method can use the
common_estimate_surrogates_analytic() method, where data is formatted
as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>process<span class="classifier">numpy array</span></dt><dd><p>realisations as either a 2D numpy array where array dimensions
represent [realisations x variable dimension] or a 1D array
representing [realisations], array type can be float (requires
discretisation) or int</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>Java object</dt><dd><p>JIDT calculator that was used here</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="idtxl.estimators_jidt.JidtDiscreteCMI">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></code><code class="sig-name descname"><span class="pre">JidtDiscreteCMI</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteCMI"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscreteCMI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtDiscrete" title="idtxl.estimators_jidt.JidtDiscrete"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimators_jidt.JidtDiscrete</span></code></a></p>
<p>Calculate CMI with JIDT’s implementation for discrete variables.</p>
<p>Calculate the conditional mutual information between two variables given
the third. Call JIDT via jpype and use the discrete estimator. See parent
class for references.</p>
<p>Results are returned in bits.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>sets estimation parameters:</p>
<ul class="simple">
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
<li><p>discretise_method : str [optional] - if and how to discretise
incoming continuous data, can be ‘max_ent’ for maximum entropy
binning, ‘equal’ for equal size bins, and ‘none’ if no binning is
required (default=’none’)</p></li>
<li><p>n_discrete_bins : int [optional] - number of discrete bins/
levels or the base of each dimension of the discrete variables
(default=2). If set, this parameter overwrites/sets alph1, alph2
and alphc</p></li>
<li><p>alph1 : int [optional] - number of discrete bins/levels for var1
(default=2, or the value set for n_discrete_bins)</p></li>
<li><p>alph2 : int [optional] - number of discrete bins/levels for var2
(default=2, or the value set for n_discrete_bins)</p></li>
<li><p>alphc : int [optional] - number of discrete bins/levels for
conditional (default=2, or the value set for n_discrete_bins)</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="idtxl.estimators_jidt.JidtDiscreteCMI.estimate">
<code class="sig-name descname"><span class="pre">estimate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conditional</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_calc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteCMI.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscreteCMI.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate conditional mutual information.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>var1<span class="classifier">numpy array</span></dt><dd><p>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations], array type can be
float (requires discretisation) or int</p>
</dd>
<dt>var2<span class="classifier">numpy array</span></dt><dd><p>realisations of the second variable (similar to var1)</p>
</dd>
<dt>conditional<span class="classifier">numpy array [optional]</span></dt><dd><p>realisations of the conditioning variable (similar to var), if
no conditional is provided, return MI between var1 and var2</p>
</dd>
<dt>return_calc<span class="classifier">boolean</span></dt><dd><p>return the calculator used here as well as the numeric
calculated value(s)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>average CMI over all samples or local CMI for individual
samples if ‘local_values’=True</p>
</dd>
<dt>Java object</dt><dd><p>JIDT calculator that was used here. Only returned if
return_calc was set.</p>
</dd>
</dl>
</dd>
<dt>Raises:</dt><dd><dl class="simple">
<dt>ex.JidtOutOfMemoryError</dt><dd><p>Raised when JIDT object cannot be instantiated due to mem error</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.estimators_jidt.JidtDiscreteCMI.get_analytic_distribution">
<code class="sig-name descname"><span class="pre">get_analytic_distribution</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conditional</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteCMI.get_analytic_distribution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscreteCMI.get_analytic_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a JIDT AnalyticNullDistribution object.</p>
<p>Required so that our estimate_surrogates_analytic method can use the
common_estimate_surrogates_analytic() method, where data is formatted
as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>var1<span class="classifier">numpy array</span></dt><dd><p>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations], array type can be
float (requires discretisation) or int</p>
</dd>
<dt>var2<span class="classifier">numpy array</span></dt><dd><p>realisations of the second variable (similar to var1)</p>
</dd>
<dt>conditional<span class="classifier">numpy array [optional]</span></dt><dd><p>realisations of the conditioning variable (similar to var), if
no conditional is provided, return MI between var1 and var2</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>Java object</dt><dd><p>JIDT calculator that was used here</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="idtxl.estimators_jidt.JidtDiscreteMI">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></code><code class="sig-name descname"><span class="pre">JidtDiscreteMI</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteMI"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscreteMI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtDiscrete" title="idtxl.estimators_jidt.JidtDiscrete"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimators_jidt.JidtDiscrete</span></code></a></p>
<p>Calculate MI with JIDT’s discrete-variable implementation.</p>
<p>Calculate the mutual information (MI) between two variables. Call JIDT via
jpype and use the discrete estimator. See parent class for references.</p>
<p>Results are returned in bits.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>sets estimation parameters:</p>
<ul class="simple">
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
<li><p>discretise_method : str [optional] - if and how to discretise
incoming continuous data, can be ‘max_ent’ for maximum entropy
binning, ‘equal’ for equal size bins, and ‘none’ if no binning is
required (default=’none’)</p></li>
<li><p>n_discrete_bins : int [optional] - number of discrete bins/
levels or the base of each dimension of the discrete variables
(default=2). If set, this parameter overwrites/sets alph1 and
alph2</p></li>
<li><p>alph1 : int [optional] - number of discrete bins/levels for var1
(default=2, or the value set for n_discrete_bins)</p></li>
<li><p>alph2 : int [optional] - number of discrete bins/levels for var2
(default=2, or the value set for n_discrete_bins)</p></li>
<li><p>lag_mi : int [optional] - time difference in samples to calculate
the lagged MI between processes (default=0)</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="idtxl.estimators_jidt.JidtDiscreteMI.estimate">
<code class="sig-name descname"><span class="pre">estimate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_calc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteMI.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscreteMI.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate mutual information.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>var1<span class="classifier">numpy array</span></dt><dd><p>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations], array type can be
float (requires discretisation) or int</p>
</dd>
<dt>var2<span class="classifier">numpy array</span></dt><dd><p>realisations of the second variable (similar to var1)</p>
</dd>
<dt>return_calc<span class="classifier">boolean</span></dt><dd><p>return the calculator used here as well as the numeric
calculated value(s)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>average MI over all samples or local MI for individual
samples if ‘local_values’=True</p>
</dd>
<dt>Java object</dt><dd><p>JIDT calculator that was used here. Only returned if
return_calc was set.</p>
</dd>
</dl>
</dd>
<dt>Raises:</dt><dd><dl class="simple">
<dt>ex.JidtOutOfMemoryError</dt><dd><p>Raised when JIDT object cannot be instantiated due to mem error</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.estimators_jidt.JidtDiscreteMI.get_analytic_distribution">
<code class="sig-name descname"><span class="pre">get_analytic_distribution</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteMI.get_analytic_distribution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscreteMI.get_analytic_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a JIDT AnalyticNullDistribution object.</p>
<p>Required so that our estimate_surrogates_analytic method can use the
common_estimate_surrogates_analytic() method, where data is formatted
as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>var1<span class="classifier">numpy array</span></dt><dd><p>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations], array type can be
float (requires discretisation) or int</p>
</dd>
<dt>var2<span class="classifier">numpy array</span></dt><dd><p>realisations of the second variable (similar to var1)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>Java object</dt><dd><p>JIDT calculator that was used here</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="idtxl.estimators_jidt.JidtDiscreteTE">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></code><code class="sig-name descname"><span class="pre">JidtDiscreteTE</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteTE"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscreteTE" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtDiscrete" title="idtxl.estimators_jidt.JidtDiscrete"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimators_jidt.JidtDiscrete</span></code></a></p>
<p>Calculate TE with JIDT’s implementation for discrete variables.</p>
<p>Calculate the transfer entropy between two time series processes.
Call JIDT via jpype and use the discrete estimator. Transfer entropy is
defined as the conditional mutual information between the source’s past
state and the target’s current value, conditional on the target’s past.
See parent class for references.</p>
<p>Results are returned in bits.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>sets estimation parameters:</p>
<ul class="simple">
<li><p>history_target : int - number of samples in the target’s past
used as embedding. (&gt;= 0)</p></li>
<li><p>history_source  : int [optional] - number of samples in the
source’s past used as embedding (default=same as the target
history). (&gt;= 1)</p></li>
<li><p>tau_source : int [optional] - source’s embedding delay
(default=1). (&gt;= 1)</p></li>
<li><p>tau_target : int [optional] - target’s embedding delay
(default=1). (&gt;= 1)</p></li>
<li><p>source_target_delay : int [optional] - information transfer delay
between source and target (default=1) (&gt;= 0)</p></li>
<li><p>discretise_method : str [optional] - if and how to discretise
incoming continuous data, can be ‘max_ent’ for maximum entropy
binning, ‘equal’ for equal size bins, and ‘none’ if no binning is
required (default=’none’)</p></li>
<li><p>n_discrete_bins : int [optional] - number of discrete bins/
levels or the base of each dimension of the discrete variables
(default=2). If set, this parameter overwrites/sets alph1 and
alph2. (&gt;= 2)</p></li>
<li><p>alph1 : int [optional] - number of discrete bins/levels for
source (default=2, or the value set for n_discrete_bins). (&gt;= 2)</p></li>
<li><p>alph2 : int [optional] - number of discrete bins/levels for
target (default=2, or the value set for n_discrete_bins). (&gt;= 2)</p></li>
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="idtxl.estimators_jidt.JidtDiscreteTE.estimate">
<code class="sig-name descname"><span class="pre">estimate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_calc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteTE.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscreteTE.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate transfer entropy from a source to a target variable.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>source<span class="classifier">numpy array</span></dt><dd><p>realisations of source variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations], array type can be
float (requires discretisation) or int</p>
</dd>
<dt>target<span class="classifier">numpy array</span></dt><dd><p>realisations of target variable (similar to var1)</p>
</dd>
<dt>return_calc<span class="classifier">boolean</span></dt><dd><p>return the calculator used here as well as the numeric
calculated value(s)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>average TE over all samples or local TE for individual
samples if ‘local_values’=True</p>
</dd>
<dt>Java object</dt><dd><p>JIDT calculator that was used here. Only returned if
return_calc was set.</p>
</dd>
</dl>
</dd>
<dt>Raises:</dt><dd><dl class="simple">
<dt>ex.JidtOutOfMemoryError</dt><dd><p>Raised when JIDT object cannot be instantiated due to mem error</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.estimators_jidt.JidtDiscreteTE.get_analytic_distribution">
<code class="sig-name descname"><span class="pre">get_analytic_distribution</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteTE.get_analytic_distribution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscreteTE.get_analytic_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a JIDT AnalyticNullDistribution object.</p>
<p>Required so that our estimate_surrogates_analytic method can use the
common_estimate_surrogates_analytic() method, where data is formatted
as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>source<span class="classifier">numpy array</span></dt><dd><p>realisations of source variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations], array type can be
float (requires discretisation) or int</p>
</dd>
<dt>target<span class="classifier">numpy array</span></dt><dd><p>realisations of target variable (similar to var1)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>Java object</dt><dd><p>JIDT calculator that was used here</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="idtxl.estimators_jidt.JidtEstimator">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></code><code class="sig-name descname"><span class="pre">JidtEstimator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtEstimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtEstimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimator.Estimator</span></code></p>
<p>Abstract class for implementation of JIDT estimators.</p>
<p>Abstract class for implementation of JIDT estimators, child classes
implement estimators for mutual information (MI), conditional mutual
information (CMI), active information storage (AIS), transfer entropy (TE)
using the Kraskov-Grassberger-Stoegbauer estimator for continuous data,
plug-in estimators for discrete data, and Gaussian estimators for
continuous Gaussian data.</p>
<p>References:</p>
<ul class="simple">
<li><p>Lizier, Joseph T. (2014). JIDT: an information-theoretic toolkit for
studying the dynamics of complex systems. Front Robot AI, 1(11).</p></li>
<li><p>Kraskov, A., Stoegbauer, H., &amp; Grassberger, P. (2004). Estimating mutual
information. Phys Rev E, 69(6), 066138.</p></li>
<li><p>Lizier, Joseph T., Mikhail Prokopenko, and Albert Y. Zomaya. (2012).
Local measures of information storage in complex distributed computation.
Inform Sci, 208, 39-54.</p></li>
<li><p>Schreiber, T. (2000). Measuring information transfer. Phys Rev Lett,
85(2), 461.</p></li>
</ul>
<p>Set common estimation parameters for JIDT estimators. For usage of these
estimators see documentation for the child classes.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>set estimator parameters:</p>
<ul class="simple">
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="idtxl.estimators_jidt.JidtEstimator.is_parallel">
<code class="sig-name descname"><span class="pre">is_parallel</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtEstimator.is_parallel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtEstimator.is_parallel" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate if estimator supports parallel estimation over chunks.</p>
<p>Return true if the supports parallel estimation over chunks, where a
chunk is one independent data set.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="idtxl.estimators_jidt.JidtGaussian">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></code><code class="sig-name descname"><span class="pre">JidtGaussian</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">CalcClass</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtGaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtEstimator" title="idtxl.estimators_jidt.JidtEstimator"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimators_jidt.JidtEstimator</span></code></a></p>
<p>Abstract class for implementation of JIDT Gaussian-estimators.</p>
<p>Abstract class for implementation of JIDT Gaussian-estimators, child
classes implement estimators for mutual information (MI), conditional
mutual information (CMI), actice information storage (AIS), transfer
entropy (TE) using JIDT’s Gaussian estimator for continuous data. See
parent class for references.</p>
<p>Set common estimation parameters for JIDT Kraskov-estimators. For usage of
these estimators see documentation for the child classes.</p>
<p>Results are returned in nats.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>CalcClass<span class="classifier">JAVA class</span></dt><dd><p>JAVA class returned by jpype.JPackage</p>
</dd>
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>set estimator parameters:</p>
<ul class="simple">
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="idtxl.estimators_jidt.JidtGaussian.estimate_surrogates_analytic">
<code class="sig-name descname"><span class="pre">estimate_surrogates_analytic</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_perm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussian.estimate_surrogates_analytic"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtGaussian.estimate_surrogates_analytic" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the surrogate distribution analytically.
This method must be implemented because this class’
is_analytic_null_estimator() method returns true</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>n_perms<span class="classifier">int</span></dt><dd><p>number of permutations (default=200)</p>
</dd>
<dt>data<span class="classifier">numpy arrays</span></dt><dd><p>realisations of random variables required for the calculation
(varies between estimators, e.g. 2 variables for MI, 3 for
CMI). Formatted as per estimate_parallel for this estimator.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>n_perm surrogates of the average MI/CMI/TE over all samples
under the null hypothesis of no relationship between var1 and
var2 (in the context of conditional)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.estimators_jidt.JidtGaussian.get_analytic_distribution">
<code class="sig-name descname"><span class="pre">get_analytic_distribution</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussian.get_analytic_distribution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtGaussian.get_analytic_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a JIDT AnalyticNullDistribution object.</p>
<p>Required so that our estimate_surrogates_analytic method can use the
common_estimate_surrogates_analytic() method, where data is formatted
as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>data<span class="classifier">numpy arrays</span></dt><dd><p>realisations of random variables required for the calculation
(varies between estimators, e.g. 2 variables for MI, 3 for
CMI). Formatted as per the estimate method for this estimator.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>Java object</dt><dd><p>JIDT calculator that was used here</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.estimators_jidt.JidtGaussian.is_analytic_null_estimator">
<code class="sig-name descname"><span class="pre">is_analytic_null_estimator</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussian.is_analytic_null_estimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtGaussian.is_analytic_null_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate if estimator supports analytic surrogates.</p>
<p>Return true if the estimator implements estimate_surrogates_analytic()
where data is formatted as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="idtxl.estimators_jidt.JidtGaussianAIS">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></code><code class="sig-name descname"><span class="pre">JidtGaussianAIS</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussianAIS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtGaussianAIS" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtGaussian" title="idtxl.estimators_jidt.JidtGaussian"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimators_jidt.JidtGaussian</span></code></a></p>
<p>Calculate active information storage with JIDT’s Gaussian implementation.</p>
<p>Calculate active information storage (AIS) for some process using JIDT’s
implementation of the Gaussian estimator. AIS is defined as the
mutual information between the processes’ past state and current value.</p>
<p>The past state needs to be defined in the settings dictionary, where a past
state is defined as a uniform embedding with parameters history and tau.
The history describes the number of samples taken from a processes’ past,
tau describes the embedding delay, i.e., the spacing between every two
samples from the processes’ past.</p>
<p>See parent class for references.Results are returned in nats.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>sets estimation parameters:</p>
<ul class="simple">
<li><p>history : int - number of samples in the processes’ past used as
embedding</p></li>
<li><p>tau : int [optional] - the processes’ embedding delay (default=1)</p></li>
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>Note:</dt><dd><p>Some technical details: JIDT normalises over realisations, IDTxl
normalises over raw data once, outside the AIS estimator to save
computation time. The Theiler window ignores trial boundaries. The
AIS estimator does add noise to the data as a default. To make analysis
runs replicable set noise_level to 0.</p>
</dd>
</dl>
<dl class="py method">
<dt id="idtxl.estimators_jidt.JidtGaussianAIS.estimate">
<code class="sig-name descname"><span class="pre">estimate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">process</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussianAIS.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtGaussianAIS.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate active information storage.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>process<span class="classifier">numpy array</span></dt><dd><p>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations]</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>average AIS over all samples or local AIS for individual
samples if ‘local_values’=True</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="idtxl.estimators_jidt.JidtGaussianCMI">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></code><code class="sig-name descname"><span class="pre">JidtGaussianCMI</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussianCMI"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtGaussianCMI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtGaussian" title="idtxl.estimators_jidt.JidtGaussian"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimators_jidt.JidtGaussian</span></code></a></p>
<p>Calculate conditional mutual infor with JIDT’s Gaussian implementation.</p>
<p>Computes the differential conditional mutual information of two
multivariate sets of observations, conditioned on another, assuming that
the probability distribution function for these observations is a
multivariate Gaussian distribution.
Call JIDT via jpype and use
ConditionalMutualInfoCalculatorMultiVariateGaussian estimator.
If no conditional is given (is None), the function returns the mutual
information between var1 and var2.</p>
<p>See parent class for references. Results are returned in nats.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>sets estimation parameters:</p>
<ul class="simple">
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>Note:</dt><dd><p>Some technical details: JIDT normalises over realisations, IDTxl
normalises over raw data once, outside the CMI estimator to save
computation time. The Theiler window ignores trial boundaries. The
CMI estimator does add noise to the data as a default. To make analysis
runs replicable set noise_level to 0.</p>
</dd>
</dl>
<dl class="py method">
<dt id="idtxl.estimators_jidt.JidtGaussianCMI.estimate">
<code class="sig-name descname"><span class="pre">estimate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conditional</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussianCMI.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtGaussianCMI.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate conditional mutual information.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>var1<span class="classifier">numpy array</span></dt><dd><p>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations]</p>
</dd>
<dt>var2<span class="classifier">numpy array</span></dt><dd><p>realisations of the second variable (similar to var1)</p>
</dd>
<dt>conditional<span class="classifier">numpy array [optional]</span></dt><dd><p>realisations of the conditioning variable (similar to var), if
no conditional is provided, return MI between var1 and var2</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>average CMI over all samples or local CMI for individual
samples if ‘local_values’=True</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.estimators_jidt.JidtGaussianCMI.get_analytic_distribution">
<code class="sig-name descname"><span class="pre">get_analytic_distribution</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conditional</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussianCMI.get_analytic_distribution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtGaussianCMI.get_analytic_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a JIDT AnalyticNullDistribution object.</p>
<p>Required so that our estimate_surrogates_analytic method can use the
common_estimate_surrogates_analytic() method, where data is formatted
as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>var1<span class="classifier">numpy array</span></dt><dd><p>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations]</p>
</dd>
<dt>var2<span class="classifier">numpy array</span></dt><dd><p>realisations of the second variable (similar to var1)</p>
</dd>
<dt>conditional<span class="classifier">numpy array [optional]</span></dt><dd><p>realisations of the conditioning variable (similar to var), if
no conditional is provided, return MI between var1 and var2</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>Java object</dt><dd><p>JIDT calculator that was used here</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="idtxl.estimators_jidt.JidtGaussianMI">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></code><code class="sig-name descname"><span class="pre">JidtGaussianMI</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussianMI"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtGaussianMI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtGaussian" title="idtxl.estimators_jidt.JidtGaussian"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimators_jidt.JidtGaussian</span></code></a></p>
<p>Calculate mutual information with JIDT’s Gaussian implementation.</p>
<p>Calculate the mutual information between two variables. Call JIDT via jpype
and use the Gaussian estimator. See parent class for references.</p>
<p>Results are returned in nats.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>sets estimation parameters:</p>
<ul class="simple">
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
<li><p>lag_mi : int [optional] - time difference in samples to calculate
the lagged MI between processes (default=0)</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>Note:</dt><dd><p>Some technical details: JIDT normalises over realisations, IDTxl
normalises over raw data once, outside the MI estimator to save
computation time. The Theiler window ignores trial boundaries. The
MI estimator does add noise to the data as a default. To make analysis
runs replicable set noise_level to 0.</p>
</dd>
</dl>
<dl class="py method">
<dt id="idtxl.estimators_jidt.JidtGaussianMI.estimate">
<code class="sig-name descname"><span class="pre">estimate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussianMI.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtGaussianMI.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate mutual information.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>var1<span class="classifier">numpy array</span></dt><dd><p>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations]</p>
</dd>
<dt>var2<span class="classifier">numpy array</span></dt><dd><p>realisations of the second variable (similar to var1)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>average MI over all samples or local MI for individual
samples if ‘local_values’=True</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="idtxl.estimators_jidt.JidtGaussianTE">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></code><code class="sig-name descname"><span class="pre">JidtGaussianTE</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussianTE"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtGaussianTE" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtGaussian" title="idtxl.estimators_jidt.JidtGaussian"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimators_jidt.JidtGaussian</span></code></a></p>
<p>Calculate transfer entropy with JIDT’s Gaussian implementation.</p>
<p>Calculate transfer entropy between a source and a target variable using
JIDT’s implementation of the Gaussian estimator. Transfer entropy is
defined as the conditional mutual information between the source’s past
state and the target’s current value, conditional on the target’s past.</p>
<p>Past states need to be defined in the settings dictionary, where a past
state is defined as a uniform embedding with parameters history and tau.
The history describes the number of samples taken from a variable’s past,
tau descrices the embedding delay, i.e., the spacing between every two
samples from the processes’ past.</p>
<p>See parent class for references. Results are returned in nats.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>sets estimation parameters:</p>
<ul class="simple">
<li><p>history_target : int - number of samples in the target’s past
used as embedding</p></li>
<li><p>history_source  : int [optional] - number of samples in the
source’s past used as embedding (default=same as the target
history)</p></li>
<li><p>tau_source : int [optional] - source’s embedding delay
(default=1)</p></li>
<li><p>tau_target : int [optional] - target’s embedding delay
(default=1)</p></li>
<li><p>source_target_delay : int [optional] - information transfer delay
between source and target (default=1)</p></li>
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>Note:</dt><dd><p>Some technical details: JIDT normalises over realisations, IDTxl
normalises over raw data once, outside the CMI estimator to save
computation time. The Theiler window ignores trial boundaries. The
CMI estimator does add noise to the data as a default. To make analysis
runs replicable set noise_level to 0.</p>
</dd>
</dl>
<dl class="py method">
<dt id="idtxl.estimators_jidt.JidtGaussianTE.estimate">
<code class="sig-name descname"><span class="pre">estimate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussianTE.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtGaussianTE.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate transfer entropy from a source to a target variable.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>source<span class="classifier">numpy array</span></dt><dd><p>realisations of source variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations]</p>
</dd>
<dt>var2<span class="classifier">numpy array</span></dt><dd><p>realisations of target variable (similar to var1)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>average TE over all samples or local TE for individual
samples if ‘local_values’=True</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="idtxl.estimators_jidt.JidtKraskov">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></code><code class="sig-name descname"><span class="pre">JidtKraskov</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">CalcClass</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtKraskov"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtKraskov" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtEstimator" title="idtxl.estimators_jidt.JidtEstimator"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimators_jidt.JidtEstimator</span></code></a></p>
<p>Abstract class for implementation of JIDT Kraskov-estimators.</p>
<p>Abstract class for implementation of JIDT Kraskov-estimators, child classes
implement estimators for mutual information (MI), conditional mutual
information (CMI), actice information storage (AIS), transfer entropy (TE)
using the Kraskov-Grassberger-Stoegbauer estimator for continuous data.
See parent class for references.</p>
<p>Set common estimation parameters for JIDT Kraskov-estimators. For usage of
these estimators see documentation for the child classes.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>CalcClass<span class="classifier">JAVA class</span></dt><dd><p>JAVA class returned by jpype.JPackage</p>
</dd>
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>set estimator parameters:</p>
<ul class="simple">
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
<li><p>kraskov_k : int [optional] - no. nearest neighbours for KNN
search (default=4)</p></li>
<li><p>normalise : bool [optional] - z-standardise data (default=False)</p></li>
<li><p>theiler_t : int [optional] - no. next temporal neighbours ignored
in KNN and range searches (default=0)</p></li>
<li><p>noise_level : float [optional] - random noise added to the data
(default=1e-8)</p></li>
<li><p>num_threads : int | str [optional] - number of threads used for
estimation (default=’USE_ALL’, note that this uses <em>all</em>
available threads on the current machine)</p></li>
<li><p>algorithm_num : int [optional] - which Kraskov algorithm (1 or 2)
to use (default=1). Only applied at this method for TE and AIS
(is already applied for MI/CMI). Note that default algorithm of 1
here is different to the default ALG_NUM argument for the JIDT
AIS KSG estimator.</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="idtxl.estimators_jidt.JidtKraskov.is_analytic_null_estimator">
<code class="sig-name descname"><span class="pre">is_analytic_null_estimator</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtKraskov.is_analytic_null_estimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtKraskov.is_analytic_null_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate if estimator supports analytic surrogates.</p>
<p>Return true if the estimator implements estimate_surrogates_analytic()
where data is formatted as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="idtxl.estimators_jidt.JidtKraskovAIS">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></code><code class="sig-name descname"><span class="pre">JidtKraskovAIS</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtKraskovAIS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtKraskovAIS" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtKraskov" title="idtxl.estimators_jidt.JidtKraskov"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimators_jidt.JidtKraskov</span></code></a></p>
<p>Calculate active information storage with JIDT’s Kraskov implementation.</p>
<p>Calculate active information storage (AIS) for some process using JIDT’s
implementation of the Kraskov type 1 estimator. AIS is defined as the
mutual information between the processes’ past state and current value.</p>
<p>The past state needs to be defined in the settings dictionary, where a past
state is defined as a uniform embedding with parameters history and tau.
The history describes the number of samples taken from a processes’ past,
tau describes the embedding delay, i.e., the spacing between every two
samples from the processes’ past.</p>
<p>See parent class for references. Results are returned in nats.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>sets estimation parameters:</p>
<ul class="simple">
<li><p>history : int - number of samples in the processes’ past used as
embedding</p></li>
<li><p>tau : int [optional] - the processes’ embedding delay (default=1)</p></li>
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
<li><p>kraskov_k : int [optional] - no. nearest neighbours for KNN
search (default=4)</p></li>
<li><p>normalise : bool [optional] - z-standardise data (default=False)</p></li>
<li><p>theiler_t : int [optional] - no. next temporal neighbours ignored
in KNN and range searches (default=0)</p></li>
<li><p>noise_level : float [optional] - random noise added to the data
(default=1e-8)</p></li>
<li><p>num_threads : int | str [optional] - number of threads used for
estimation (default=’USE_ALL’, note that this uses <em>all</em>
available threads on the current machine)</p></li>
<li><p>algorithm_num : int [optional] - which Kraskov algorithm (1 or 2)
to use (default=1)</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>Note:</dt><dd><p>Some technical details: JIDT normalises over realisations, IDTxl
normalises over raw data once, outside the AIS estimator to save
computation time. The Theiler window ignores trial boundaries. The
AIS estimator does add noise to the data as a default. To make analysis
runs replicable set noise_level to 0.</p>
</dd>
</dl>
<dl class="py method">
<dt id="idtxl.estimators_jidt.JidtKraskovAIS.estimate">
<code class="sig-name descname"><span class="pre">estimate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">process</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtKraskovAIS.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtKraskovAIS.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate active information storage.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>process<span class="classifier">numpy array</span></dt><dd><p>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations]</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>average AIS over all samples or local AIS for individual
samples if ‘local_values’=True</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="idtxl.estimators_jidt.JidtKraskovCMI">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></code><code class="sig-name descname"><span class="pre">JidtKraskovCMI</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtKraskovCMI"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtKraskovCMI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtKraskov" title="idtxl.estimators_jidt.JidtKraskov"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimators_jidt.JidtKraskov</span></code></a></p>
<p>Calculate conditional mutual inform with JIDT’s Kraskov implementation.</p>
<p>Calculate the conditional mutual information (CMI) between three variables.
Call JIDT via jpype and use the Kraskov 1 estimator. If no conditional is
given (is None), the function returns the mutual information between var1
and var2. See parent class for references.</p>
<blockquote>
<div><p>Results are returned in nats.</p>
</div></blockquote>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>set estimator parameters:</p>
<ul class="simple">
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
<li><p>kraskov_k : int [optional] - no. nearest neighbours for KNN
search (default=4)</p></li>
<li><p>normalise : bool [optional] - z-standardise data (default=False)</p></li>
<li><p>theiler_t : int [optional] - no. next temporal neighbours ignored
in KNN and range searches (default=0)</p></li>
<li><p>noise_level : float [optional] - random noise added to the data
(default=1e-8)</p></li>
<li><p>num_threads : int | str [optional] - number of threads used for
estimation (default=’USE_ALL’, note that this uses <em>all</em>
available threads on the current machine)</p></li>
<li><p>algorithm_num : int [optional] - which Kraskov algorithm (1 or 2)
to use (default=1)</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>Note:</dt><dd><p>Some technical details: JIDT normalises over realisations, IDTxl
normalises over raw data once, outside the CMI estimator to save
computation time. The Theiler window ignores trial boundaries. The
CMI estimator does add noise to the data as a default. To make analysis
runs replicable set noise_level to 0.</p>
</dd>
</dl>
<dl class="py method">
<dt id="idtxl.estimators_jidt.JidtKraskovCMI.estimate">
<code class="sig-name descname"><span class="pre">estimate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conditional</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtKraskovCMI.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtKraskovCMI.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate conditional mutual information.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>var1<span class="classifier">numpy array</span></dt><dd><p>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations]</p>
</dd>
<dt>var2<span class="classifier">numpy array</span></dt><dd><p>realisations of the second variable (similar to var1)</p>
</dd>
<dt>conditional<span class="classifier">numpy array [optional]</span></dt><dd><p>realisations of the conditioning variable (similar to var), if
no conditional is provided, return MI between var1 and var2</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>average CMI over all samples or local CMI for individual
samples if ‘local_values’=True</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="idtxl.estimators_jidt.JidtKraskovMI">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></code><code class="sig-name descname"><span class="pre">JidtKraskovMI</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtKraskovMI"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtKraskovMI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtKraskov" title="idtxl.estimators_jidt.JidtKraskov"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimators_jidt.JidtKraskov</span></code></a></p>
<p>Calculate mutual information with JIDT’s Kraskov implementation.</p>
<p>Calculate the mutual information between two variables. Call JIDT via jpype
and use the Kraskov 1 estimator. See parent class for references.</p>
<p>Results are returned in nats.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>sets estimation parameters:</p>
<ul class="simple">
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
<li><p>kraskov_k : int [optional] - no. nearest neighbours for KNN
search (default=4)</p></li>
<li><p>normalise : bool [optional] - z-standardise data (default=False)</p></li>
<li><p>theiler_t : int [optional] - no. next temporal neighbours ignored
in KNN and range searches (default=0)</p></li>
<li><p>noise_level : float [optional] - random noise added to the data
(default=1e-8)</p></li>
<li><p>num_threads : int | str [optional] - number of threads used for
estimation (default=’USE_ALL’, note that this uses <em>all</em>
available threads on the current machine)</p></li>
<li><p>algorithm_num : int [optional] - which Kraskov algorithm (1 or 2)
to use (default=1)</p></li>
<li><p>lag_mi : int [optional] - time difference in samples to calculate
the lagged MI between processes (default=0)</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>Note:</dt><dd><p>Some technical details: JIDT normalises over realisations, IDTxl
normalises over raw data once, outside the MI estimator to save
computation time. The Theiler window ignores trial boundaries. The
MI estimator does add noise to the data as a default. To make analysis
runs replicable set noise_level to 0.</p>
</dd>
</dl>
<dl class="py method">
<dt id="idtxl.estimators_jidt.JidtKraskovMI.estimate">
<code class="sig-name descname"><span class="pre">estimate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtKraskovMI.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtKraskovMI.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate mutual information.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>var1<span class="classifier">numpy array</span></dt><dd><p>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations]</p>
</dd>
<dt>var2<span class="classifier">numpy array</span></dt><dd><p>realisations of the second variable (similar to var1)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>average MI over all samples or local MI for individual
samples if ‘local_values’=True</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="idtxl.estimators_jidt.JidtKraskovTE">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></code><code class="sig-name descname"><span class="pre">JidtKraskovTE</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtKraskovTE"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtKraskovTE" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtKraskov" title="idtxl.estimators_jidt.JidtKraskov"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimators_jidt.JidtKraskov</span></code></a></p>
<p>Calculate transfer entropy with JIDT’s Kraskov implementation.</p>
<p>Calculate transfer entropy between a source and a target variable using
JIDT’s implementation of the Kraskov type 1 estimator. Transfer entropy is
defined as the conditional mutual information between the source’s past
state and the target’s current value, conditional on the target’s past.</p>
<p>Past states need to be defined in the settings dictionary, where a past
state is defined as a uniform embedding with parameters history and tau.
The history describes the number of samples taken from a variable’s past,
tau descrices the embedding delay, i.e., the spacing between every two
samples from the processes’ past.</p>
<p>See parent class for references. Results are returned in nats.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>sets estimation parameters:</p>
<ul class="simple">
<li><p>history_target : int - number of samples in the target’s past
used as embedding</p></li>
<li><p>history_source  : int [optional] - number of samples in the
source’s past used as embedding (default=same as the target
history)</p></li>
<li><p>tau_source : int [optional] - source’s embedding delay
(default=1)</p></li>
<li><p>tau_target : int [optional] - target’s embedding delay
(default=1)</p></li>
<li><p>source_target_delay : int [optional] - information transfer delay
between source and target (default=1)</p></li>
<li><p>debug : bool [optional] - return debug information when calling
JIDT (default=False)</p></li>
<li><p>local_values : bool [optional] - return local TE instead of
average TE (default=False)</p></li>
<li><p>algorithm_num : int [optional] - which Kraskov algorithm (1 or 2)
to use (default=1)</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>Note:</dt><dd><p>Some technical details: JIDT normalises over realisations, IDTxl
normalises over raw data once, outside the CMI estimator to save
computation time. The Theiler window ignores trial boundaries. The
CMI estimator does add noise to the data as a default. To make analysis
runs replicable set noise_level to 0.</p>
</dd>
</dl>
<dl class="py method">
<dt id="idtxl.estimators_jidt.JidtKraskovTE.estimate">
<code class="sig-name descname"><span class="pre">estimate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtKraskovTE.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtKraskovTE.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate transfer entropy from a source to a target variable.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>source<span class="classifier">numpy array</span></dt><dd><p>realisations of source variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations]</p>
</dd>
<dt>var2<span class="classifier">numpy array</span></dt><dd><p>realisations of target variable (similar to var1)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>average TE over all samples or local TE for individual
samples if ‘local_values’=True</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="idtxl.estimators_jidt.common_estimate_surrogates_analytic">
<code class="sig-prename descclassname"><span class="pre">idtxl.estimators_jidt.</span></code><code class="sig-name descname"><span class="pre">common_estimate_surrogates_analytic</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">estimator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_perm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#common_estimate_surrogates_analytic"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_jidt.common_estimate_surrogates_analytic" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the surrogate distribution analytically for JidtEstimator.</p>
<p>Estimate the surrogate distribution analytically for a JidtEstimator
which is_analytic_null_estimator(), by sampling estimates at random
p-values in the analytic distribution.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>estimator<span class="classifier">a JidtEstimator object, which returns True to a call to</span></dt><dd><p>its is_analytic_null_estimator() method</p>
</dd>
<dt>n_perms<span class="classifier">int</span></dt><dd><p>number of permutations (default=200)</p>
</dd>
<dt>data<span class="classifier">numpy arrays</span></dt><dd><p>realisations of random variables required for the calculation
(varies between estimators, e.g. 2 variables for MI, 3 for CMI)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>n_perm surrogates of the average MI/CMI/TE over all samples
under the null hypothesis of no relationship between var1 and
var2 (in the context of conditional)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-idtxl.estimators_opencl">
<span id="idtxl-estimators-opencl-module"></span><h2>idtxl.estimators_opencl module<a class="headerlink" href="#module-idtxl.estimators_opencl" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="idtxl.estimators_opencl.OpenCLKraskov">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.estimators_opencl.</span></code><code class="sig-name descname"><span class="pre">OpenCLKraskov</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_opencl.html#OpenCLKraskov"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_opencl.OpenCLKraskov" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimator.Estimator</span></code></p>
<p>Abstract class for implementation of OpenCL estimators.</p>
<p>Abstract class for implementation of OpenCL estimators, child classes
implement estimators for mutual information (MI) and conditional mutual
information (CMI) using the Kraskov-Grassberger-Stoegbauer estimator for
continuous data.</p>
<p>References:</p>
<ul class="simple">
<li><p>Kraskov, A., Stoegbauer, H., &amp; Grassberger, P. (2004). Estimating mutual
information. Phys Rev E, 69(6), 066138.</p></li>
<li><p>Lizier, Joseph T., Mikhail Prokopenko, and Albert Y. Zomaya. (2012).
Local measures of information storage in complex distributed computation.
Inform Sci, 208, 39-54.</p></li>
<li><p>Schreiber, T. (2000). Measuring information transfer. Phys Rev Lett,
85(2), 461.</p></li>
</ul>
<p>Estimators can be used to perform multiple, independent searches in
parallel. Each of these parallel searches is called a ‘chunk’. To search
multiple chunks, provide point sets as 2D arrays, where the first
dimension represents samples or points, and the second dimension
represents the points’ dimensions. Concatenate chunk data in the first
dimension and pass the number of chunks to the estimators. Chunks must be
of equal size.</p>
<p>Set common estimation parameters for OpenCL estimators. For usage of these
estimators see documentation for the child classes.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>set estimator parameters:</p>
<ul class="simple">
<li><p>gpuid : int [optional] - device ID used for estimation (if more
than one device is available on the current platform) (default=0)</p></li>
<li><p>kraskov_k : int [optional] - no. nearest neighbours for KNN
search (default=4)</p></li>
<li><p>normalise : bool [optional] - z-standardise data (default=False)</p></li>
<li><p>theiler_t : int [optional] - no. next temporal neighbours ignored
in KNN and range searches (default=0)</p></li>
<li><p>noise_level : float [optional] - random noise added to the data
(default=1e-8)</p></li>
<li><p>padding : bool [optional] - pad data to a length that is a
multiple of 1024, workaround for a</p></li>
<li><p>debug : bool [optional] - calculate intermediate results, i.e.
neighbour counts from range searches and KNN distances, print
debug output to console (default=False)</p></li>
<li><p>return_counts : bool [optional] - return intermediate results,
i.e. neighbour counts from range searches and KNN distances
(default=False)</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="idtxl.estimators_opencl.OpenCLKraskov.is_analytic_null_estimator">
<code class="sig-name descname"><span class="pre">is_analytic_null_estimator</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_opencl.html#OpenCLKraskov.is_analytic_null_estimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_opencl.OpenCLKraskov.is_analytic_null_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate if estimator supports analytic surrogates.</p>
<p>Return true if the estimator implements estimate_surrogates_analytic()
where data is formatted as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.estimators_opencl.OpenCLKraskov.is_parallel">
<code class="sig-name descname"><span class="pre">is_parallel</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_opencl.html#OpenCLKraskov.is_parallel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_opencl.OpenCLKraskov.is_parallel" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate if estimator supports parallel estimation over chunks.</p>
<p>Return true if the supports parallel estimation over chunks, where a
chunk is one independent data set.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="idtxl.estimators_opencl.OpenCLKraskovCMI">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.estimators_opencl.</span></code><code class="sig-name descname"><span class="pre">OpenCLKraskovCMI</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_opencl.html#OpenCLKraskovCMI"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_opencl.OpenCLKraskovCMI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_opencl.OpenCLKraskov" title="idtxl.estimators_opencl.OpenCLKraskov"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimators_opencl.OpenCLKraskov</span></code></a></p>
<p>Calculate conditional mutual inform with OpenCL Kraskov implementation.</p>
<p>Calculate the conditional mutual information (CMI) between three variables
using OpenCL GPU-code. If no conditional is given (is None), the function
returns the mutual information between var1 and var2. See parent class for
references.</p>
<p>Results are returned in nats.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>set estimator parameters:</p>
<ul class="simple">
<li><p>gpuid : int [optional] - device ID used for estimation (if more
than one device is available on the current platform) (default=0)</p></li>
<li><p>kraskov_k : int [optional] - no. nearest neighbours for KNN
search (default=4)</p></li>
<li><p>normalise : bool [optional] - z-standardise data (default=False)</p></li>
<li><p>theiler_t : int [optional] - no. next temporal neighbours ignored
in KNN and range searches (default=0)</p></li>
<li><p>noise_level : float [optional] - random noise added to the data
(default=1e-8)</p></li>
<li><p>debug : bool [optional] - return intermediate results, i.e.
neighbour counts from range searches and KNN distances
(default=False)</p></li>
<li><p>return_counts : bool [optional] - return intermediate results,
i.e. neighbour counts from range searches and KNN distances
(default=False)</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="idtxl.estimators_opencl.OpenCLKraskovCMI.estimate">
<code class="sig-name descname"><span class="pre">estimate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conditional</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_chunks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_opencl.html#OpenCLKraskovCMI.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_opencl.OpenCLKraskovCMI.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate conditional mutual information.</p>
<p>If conditional is None, the mutual information between var1 and var2 is
calculated.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>var1<span class="classifier">numpy array</span></dt><dd><p>realisations of first variable, either a 2D numpy array where
array dimensions represent [(realisations * n_chunks) x
variable dimension] or a 1D array representing [realisations],
array type should be int32</p>
</dd>
<dt>var2<span class="classifier">numpy array</span></dt><dd><p>realisations of the second variable (similar to var1)</p>
</dd>
<dt>conditional<span class="classifier">numpy array</span></dt><dd><p>realisations of conditioning variable (similar to var1)</p>
</dd>
<dt>n_chunks<span class="classifier">int</span></dt><dd><p>number of data chunks, no. data points has to be the same for
each chunk</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>average CMI over all samples or local CMI for individual
samples if ‘local_values’=True</p>
</dd>
<dt>numpy arrays</dt><dd><p>distances and neighborhood counts for var1 and var2 if
debug=True and return_counts=True</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="idtxl.estimators_opencl.OpenCLKraskovMI">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.estimators_opencl.</span></code><code class="sig-name descname"><span class="pre">OpenCLKraskovMI</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_opencl.html#OpenCLKraskovMI"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_opencl.OpenCLKraskovMI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_opencl.OpenCLKraskov" title="idtxl.estimators_opencl.OpenCLKraskov"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimators_opencl.OpenCLKraskov</span></code></a></p>
<p>Calculate mutual information with OpenCL Kraskov implementation.</p>
<p>Calculate the mutual information (MI) between two variables using OpenCL
GPU-code. See parent class for references.</p>
<p>Results are returned in nats.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>set estimator parameters:</p>
<ul class="simple">
<li><p>gpuid : int [optional] - device ID used for estimation (if more
than one device is available on the current platform) (default=0)</p></li>
<li><p>kraskov_k : int [optional] - no. nearest neighbours for KNN
search (default=4)</p></li>
<li><p>normalise : bool [optional] - z-standardise data (default=False)</p></li>
<li><p>theiler_t : int [optional] - no. next temporal neighbours ignored
in KNN and range searches (default=0)</p></li>
<li><p>noise_level : float [optional] - random noise added to the data
(default=1e-8)</p></li>
<li><p>debug : bool [optional] - return intermediate results, i.e.
neighbour counts from range searches and KNN distances
(default=False)</p></li>
<li><p>return_counts : bool [optional] - return intermediate results,
i.e. neighbour counts from range searches and KNN distances
(default=False)</p></li>
<li><p>lag_mi : int [optional] - time difference in samples to calculate
the lagged MI between processes (default=0)</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="idtxl.estimators_opencl.OpenCLKraskovMI.estimate">
<code class="sig-name descname"><span class="pre">estimate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_chunks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_opencl.html#OpenCLKraskovMI.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_opencl.OpenCLKraskovMI.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate mutual information.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>var1<span class="classifier">numpy array</span></dt><dd><p>realisations of first variable, either a 2D numpy array where
array dimensions represent [(realisations * n_chunks) x
variable dimension] or a 1D array representing [realisations],
array type should be int32</p>
</dd>
<dt>var2<span class="classifier">numpy array</span></dt><dd><p>realisations of the second variable (similar to var1)</p>
</dd>
<dt>n_chunks<span class="classifier">int</span></dt><dd><p>number of data chunks, no. data points has to be the same for
each chunk</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float | numpy array</dt><dd><p>average MI over all samples or local MI for individual
samples if ‘local_values’=True</p>
</dd>
<dt>numpy arrays</dt><dd><p>distances and neighborhood counts for var1 and var2 if
debug=True and return_counts=True</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-idtxl.estimators_multivariate_pid">
<span id="idtxl-estimators-multivariate-pid-module"></span><h2>idtxl.estimators_multivariate_pid module<a class="headerlink" href="#module-idtxl.estimators_multivariate_pid" title="Permalink to this headline">¶</a></h2>
<p>Multivariate Partical information decomposition for discrete random variables.</p>
<p>This module provides an estimator for multivariate partial information
decomposition as proposed in</p>
<ul class="simple">
<li><p>Makkeh, A. &amp; Gutknecht, A. &amp; Wibral, M. (2020). A Differentiable measure
for shared information. 1- 27 Retrieved from
<a class="reference external" href="http://arxiv.org/abs/2002.03356">http://arxiv.org/abs/2002.03356</a></p></li>
</ul>
<dl class="py class">
<dt id="idtxl.estimators_multivariate_pid.SxPID">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.estimators_multivariate_pid.</span></code><code class="sig-name descname"><span class="pre">SxPID</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_multivariate_pid.html#SxPID"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_multivariate_pid.SxPID" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimator.Estimator</span></code></p>
<p>Estimate partial information decomposition for multiple inputs.</p>
<p>Implementation of the multivariate partial information decomposition (PID)
estimator for discrete data with (up to 4 inputs) and one output. The
estimator finds shared information, unique information and synergistic
information between the multiple inputs s1, s2, …, sn with respect to the
output t for each realization (t, s1, …, sn) and then average them
according to their distribution weights p(t, s1, …, sn). Both the
pointwise (on the realization level) PID and the averaged PID are returned
(see the ‘return’ of ‘estimate()’).</p>
<p>The algorithm uses recursion to compute the partial information
decomposition.</p>
<p>References:</p>
<ul class="simple">
<li><p>Makkeh, A. &amp; Wibral, M. (2020). A differentiable pointwise partial
Information Decomposition estimator. <a class="reference external" href="https://github.com/Abzinger/SxPID">https://github.com/Abzinger/SxPID</a>.</p></li>
</ul>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>estimation parameters (with default parameters)</p>
<ul class="simple">
<li><p>verbose : bool [optional] - print output to console
(default=False)</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="idtxl.estimators_multivariate_pid.SxPID.estimate">
<code class="sig-name descname"><span class="pre">estimate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_multivariate_pid.html#SxPID.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_multivariate_pid.SxPID.estimate" title="Permalink to this definition">¶</a></dt>
<dd><dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>s<span class="classifier">list of numpy arrays</span></dt><dd><p>1D arrays containing realizations of a discrete random variable</p>
</dd>
<dt>t<span class="classifier">numpy array</span></dt><dd><p>1D array containing realizations of a discrete random variable</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl>
<dt>dict of dict</dt><dd><dl>
<dt>{</dt><dd><p>‘ptw’ -&gt; { realization -&gt; {alpha -&gt; [float, float, float]} }</p>
<p>‘avg’ -&gt; {alpha -&gt; [float, float, float]}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>where the list of floats is ordered
[informative, misinformative, informative - misinformative]
ptw stands for pointwise decomposition
avg stands for average decomposition</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.estimators_multivariate_pid.SxPID.is_analytic_null_estimator">
<code class="sig-name descname"><span class="pre">is_analytic_null_estimator</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_multivariate_pid.html#SxPID.is_analytic_null_estimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_multivariate_pid.SxPID.is_analytic_null_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate if estimator supports analytic surrogates.</p>
<p>Return true if the estimator implements estimate_surrogates_analytic()
where data is formatted as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.estimators_multivariate_pid.SxPID.is_parallel">
<code class="sig-name descname"><span class="pre">is_parallel</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_multivariate_pid.html#SxPID.is_parallel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_multivariate_pid.SxPID.is_parallel" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate if estimator supports parallel estimation over chunks.</p>
<p>Return true if the supports parallel estimation over chunks, where a
chunk is one independent data set.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-idtxl.estimators_pid">
<span id="idtxl-estimators-pid-module"></span><h2>idtxl.estimators_pid module<a class="headerlink" href="#module-idtxl.estimators_pid" title="Permalink to this headline">¶</a></h2>
<p>Partical information decomposition for discrete random variables.</p>
<p>This module provides an estimator for partial information decomposition
as proposed in</p>
<p>Bertschinger, N., Rauh, J., Olbrich, E., Jost, J., &amp; Ay, N. (2014). Quantifying
Unique Information. Entropy, 16(4), 2161–2183. <a class="reference external" href="http://doi.org/10.3390/e16042161">http://doi.org/10.3390/e16042161</a></p>
<dl class="py class">
<dt id="idtxl.estimators_pid.SydneyPID">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.estimators_pid.</span></code><code class="sig-name descname"><span class="pre">SydneyPID</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_pid.html#SydneyPID"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_pid.SydneyPID" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimator.Estimator</span></code></p>
<p>Estimate partial information decomposition of discrete variables.</p>
<p>Fast implementation of the BROJA partial information decomposition (PID)
estimator for discrete data (Bertschinger, 2014). The estimator does not
require JAVA or GPU modules to run.</p>
<p>The estimator finds shared information, unique information and
synergistic information between the two inputs s1 and s2 with respect to
the output t.</p>
<p>Improved version with larger initial swaps and checking for convergence of
both the unique information from sources 1 and 2. The function counts the
empirical observations, calculates probabilities and the initial CMI, then
does the vitrualised swaps until it has converged, and finally calculates
the PID. The virtualised swaps stage contains two loops. An inner loop
which actually does the virtualised swapping, keeping the changes if the
CMI decreases; and an outer loop which decreases the size of the
probability mass increment the virtualised swapping utilises.</p>
<p>References</p>
<ul class="simple">
<li><p>Bertschinger, N., Rauh, J., Olbrich, E., Jost, J., &amp; Ay, N. (2014).
Quantifying unique information. Entropy, 16(4), 2161–2183.
<a class="reference external" href="http://doi.org/10.3390/e16042161">http://doi.org/10.3390/e16042161</a></p></li>
</ul>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>estimation parameters</p>
<ul class="simple">
<li><p>alph_s1 : int - alphabet size of s1</p></li>
<li><p>alph_s2 : int - alphabet size of s2</p></li>
<li><p>alph_t : int - alphabet size of t</p></li>
<li><p>max_unsuc_swaps_row_parm : int - soft limit for virtualised swaps
based on the number of unsuccessful swaps attempted in a row.
If there are too many unsuccessful swaps in a row, then it
will break the inner swap loop; the outer loop decrements the
size of the probability mass increment and then attemps
virtualised swaps again with the smaller probability increment.
The exact number of unsuccessful swaps allowed before breaking
is the total number of possible swaps (given our alphabet
sizes) times the control parameter max_unsuc_swaps_row_parm,
e.g., if the parameter is set to 3, this gives a high degree of
confidence that nearly (if not) all of the possible swaps have
been attempted before this soft limit breaks the swap loop.</p></li>
<li><p>num_reps : int -  number of times the outer loop will halve the
size of the probability increment used for the virtualised
swaps. This is in direct correspondence with the number of times
the empirical data was replicated in your original
implementation.</p></li>
<li><p>max_iters : int - provides a hard upper bound on the number of
times it will attempt to perform virtualised swaps in the inner
loop. However, this hard limit is (practically) never used as it
should always hit the soft limit defined above (parameter may be
removed in the future).</p></li>
<li><p>verbose : bool [optional] - print output to console
(default=False)</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="idtxl.estimators_pid.SydneyPID.estimate">
<code class="sig-name descname"><span class="pre">estimate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_pid.html#SydneyPID.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_pid.SydneyPID.estimate" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>s1<span class="classifier">numpy array</span></dt><dd><p>1D array containing realizations of a discrete random variable</p>
</dd>
<dt>s2<span class="classifier">numpy array</span></dt><dd><p>1D array containing realizations of a discrete random variable</p>
</dd>
<dt>t<span class="classifier">numpy array</span></dt><dd><p>1D array containing realizations of a discrete random variable</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>dict</dt><dd><p>estimated decomposition, contains the joint distribution,
unique, shared, and synergistic information</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.estimators_pid.SydneyPID.is_analytic_null_estimator">
<code class="sig-name descname"><span class="pre">is_analytic_null_estimator</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_pid.html#SydneyPID.is_analytic_null_estimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_pid.SydneyPID.is_analytic_null_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate if estimator supports analytic surrogates.</p>
<p>Return true if the estimator implements estimate_surrogates_analytic()
where data is formatted as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.estimators_pid.SydneyPID.is_parallel">
<code class="sig-name descname"><span class="pre">is_parallel</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_pid.html#SydneyPID.is_parallel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_pid.SydneyPID.is_parallel" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate if estimator supports parallel estimation over chunks.</p>
<p>Return true if the supports parallel estimation over chunks, where a
chunk is one independent data set.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="idtxl.estimators_pid.TartuPID">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.estimators_pid.</span></code><code class="sig-name descname"><span class="pre">TartuPID</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_pid.html#TartuPID"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_pid.TartuPID" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.estimator.Estimator</span></code></p>
<p>Estimate partial information decomposition for two inputs and one output</p>
<p>Implementation of the partial information decomposition (PID) estimator for
discrete data. The estimator finds shared information, unique information
and synergistic information between the two inputs s1 and s2 with respect
to the output t.</p>
<p>The algorithm uses exponential cone programming and requires the Python
package for ECOS: Embedded Cone Solver (<a class="reference external" href="https://pypi.python.org/pypi/ecos">https://pypi.python.org/pypi/ecos</a>).</p>
<p>References:</p>
<ul class="simple">
<li><p>Makkeh, A., Theis, D.O., &amp; Vicente, R. (2017). Bivariate Partial
Information Decomposition: The Optimization Perspective. Entropy, 19(10),
530.</p></li>
<li><p>Makkeh, A., Theis, D.O., &amp; Vicente, R. (2018). BROJA-2PID: A cone
programming based Partial Information Decomposition estimator. Entropy,
20(271), <a class="reference external" href="https://github.com/Abzinger/BROJA_2PID">https://github.com/Abzinger/BROJA_2PID</a>.</p></li>
</ul>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>estimation parameters (with default parameters)</p>
<ul class="simple">
<li><p>verbose : bool [optional] - print output to console
(default=False)</p></li>
<li><p>cone_solver : str [optional] - which cone solver to use
(default=’ECOS’)</p></li>
<li><p>solver_args : dict [optional] - solver arguments (default={})</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="idtxl.estimators_pid.TartuPID.estimate">
<code class="sig-name descname"><span class="pre">estimate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_pid.html#TartuPID.estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_pid.TartuPID.estimate" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>s1<span class="classifier">numpy array</span></dt><dd><p>1D array containing realizations of a discrete random variable</p>
</dd>
<dt>s2<span class="classifier">numpy array</span></dt><dd><p>1D array containing realizations of a discrete random variable</p>
</dd>
<dt>t<span class="classifier">numpy array</span></dt><dd><p>1D array containing realizations of a discrete random variable</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>dict</dt><dd><p>estimated decomposition, solver used, numerical error</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.estimators_pid.TartuPID.is_analytic_null_estimator">
<code class="sig-name descname"><span class="pre">is_analytic_null_estimator</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_pid.html#TartuPID.is_analytic_null_estimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_pid.TartuPID.is_analytic_null_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate if estimator supports analytic surrogates.</p>
<p>Return true if the estimator implements estimate_surrogates_analytic()
where data is formatted as per the estimate method for this estimator.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.estimators_pid.TartuPID.is_parallel">
<code class="sig-name descname"><span class="pre">is_parallel</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_pid.html#TartuPID.is_parallel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.estimators_pid.TartuPID.is_parallel" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate if estimator supports parallel estimation over chunks.</p>
<p>Return true if the supports parallel estimation over chunks, where a
chunk is one independent data set.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-idtxl.idtxl_import">
<span id="idtxl-idtxl-import-module"></span><h2>idtxl.idtxl_import module<a class="headerlink" href="#module-idtxl.idtxl_import" title="Permalink to this headline">¶</a></h2>
<p>Import external file formats into IDTxl.</p>
<p>Provide functions to import the following into IDTxl:</p>
<blockquote>
<div><ul class="simple">
<li><p>mat-files (version&gt;7.3, hdf5)</p></li>
<li><p>FieldTrip-style mat-files (version&gt;7.3, hdf5)</p></li>
</ul>
</div></blockquote>
<p>Matlab supports hdf5 only for files saved as version 7.3 or higher:
<a class="reference external" href="https://au.mathworks.com/help/matlab/ref/save.html#inputarg_version">https://au.mathworks.com/help/matlab/ref/save.html#inputarg_version</a></p>
<p>Creates a numpy array usable as input to IDTxl.</p>
<dl>
<dt>Methods:</dt><dd><p>ft_trial_2_numpyarray(file_name, ft_struct_name)
matarray2idtxlconverter(file_name, array_name, order) =     takes a file_name,</p>
<blockquote>
<div><p>the name of the array variable (array_name) inside,
and the order of sensor axis,  time axisand (CHECK THIS!!)
repetition axis (as a list)</p>
</div></blockquote>
</dd>
<dt>Note:</dt><dd><p>Written for Python 3.4+</p>
</dd>
</dl>
<p>Created on Wed Mar 19 12:34:36 2014</p>
<p>&#64;author: Michael Wibral</p>
<dl class="py function">
<dt id="idtxl.idtxl_import.import_fieldtrip">
<code class="sig-prename descclassname"><span class="pre">idtxl.idtxl_import.</span></code><code class="sig-name descname"><span class="pre">import_fieldtrip</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ft_struct_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_version</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_import.html#import_fieldtrip"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_import.import_fieldtrip" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert FieldTrip-style MATLAB-file into an IDTxl Data object.</p>
<p>Import a MATLAB structure with fields  “trial” (data), “label” (channel
labels), “time” (time stamps for data samples), and “fsample” (sampling
rate). This structure is the standard file format in the MATLAB toolbox
FieldTrip and commonly use to represent neurophysiological data (see also
<a class="reference external" href="http://www.fieldtriptoolbox.org/reference/ft_datatype_raw">http://www.fieldtriptoolbox.org/reference/ft_datatype_raw</a>). The data is
returned as a IDTxl Data() object.</p>
<p>The structure is assumed to be saved as a matlab hdf5 file (“-v7.3’ or
higher, .mat) with a SINGLE FieldTrip data structure inside.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>file_name<span class="classifier">string</span></dt><dd><p>full (matlab) file_name on disk</p>
</dd>
<dt>ft_struct_name<span class="classifier">string</span></dt><dd><p>variable name of the MATLAB structure that is in FieldTrip format
(autodetect will hopefully be possible later …)</p>
</dd>
<dt>file_version<span class="classifier">string</span></dt><dd><p>version of the file, e.g. ‘v7.3’ for MATLAB’s 7.3 format</p>
</dd>
<dt>normalise<span class="classifier">bool [optional]</span></dt><dd><p>normalise data after import (default=True)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>Data() instance</dt><dd><p>instance of IDTxl Data object, containing data from the ‘trial’
field</p>
</dd>
<dt>list of strings</dt><dd><p>list of channel labels, corresponding to the ‘label’ field</p>
</dd>
<dt>numpy array</dt><dd><p>time stamps for samples, corresponding to one entry in the ‘time’
field</p>
</dd>
<dt>int</dt><dd><p>sampling rate, corresponding to the ‘fsample’ field</p>
</dd>
</dl>
</dd>
</dl>
<p>&#64;author: Michael Wibral</p>
</dd></dl>

<dl class="py function">
<dt id="idtxl.idtxl_import.import_matarray">
<code class="sig-prename descclassname"><span class="pre">idtxl.idtxl_import.</span></code><code class="sig-name descname"><span class="pre">import_matarray</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">array_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_version</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_import.html#import_matarray"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_import.import_matarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Read Matlab hdf5 file into IDTxl.</p>
<p>reads a matlab hdf5 file (“-v7.3’ or higher, .mat) with a SINGLE
array inside and returns a numpy array with dimensions that
are channel x time x trials, using np.swapaxes where necessary</p>
<dl class="simple">
<dt>Note:</dt><dd><p>The import function squeezes the loaded mat-file, i.e., any singleton
dimension will be removed. Hence do not enter singleton dimension into
the ‘dim_order’, e.g., don’t pass dim_order=’ps’ but dim_order=’s‘ if
you want to load a 1D-array where entries represent samples recorded
from a single channel.</p>
</dd>
<dt>Args:</dt><dd><dl class="simple">
<dt>file_name<span class="classifier">string</span></dt><dd><p>full (matlab) file_name on disk</p>
</dd>
<dt>array_name<span class="classifier">string</span></dt><dd><p>variable name of the MATLAB structure to be read</p>
</dd>
<dt>file_version<span class="classifier">string</span></dt><dd><p>version of the file, e.g. ‘v7.3’ for MATLAB’s 7.3 format, currently
versions ‘v4’, ‘v6’, ‘v7’, and ‘v7’ are supported</p>
</dd>
<dt>dim_order<span class="classifier">string</span></dt><dd><p>order of dimensions, accepts any combination of the characters
‘p’, ‘s’, and ‘r’ for processes, samples, and replications; must
have the same length as the data dimensionality, e.g., ‘ps’ for a
two-dimensional array of data from several processes over time</p>
</dd>
<dt>normalise<span class="classifier">bool [optional]</span></dt><dd><p>normalise data after import (default=True)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>Data() instance</dt><dd><p>instance of IDTxl Data object, containing data from the ‘trial’
field</p>
</dd>
<dt>list of strings</dt><dd><p>list of channel labels, corresponding to the ‘label’ field</p>
</dd>
<dt>numpy array</dt><dd><p>time stamps for samples, corresponding to one entry in the ‘time’
field</p>
</dd>
<dt>int</dt><dd><p>sampling rate, corresponding to the ‘fsample’ field</p>
</dd>
</dl>
</dd>
</dl>
<p>Created on Wed Mar 19 12:34:36 2014</p>
<p>&#64;author: Michael Wibral</p>
</dd></dl>

</div>
<div class="section" id="module-idtxl.idtxl_exceptions">
<span id="idtxl-idtxl-exceptions-module"></span><h2>idtxl.idtxl_exceptions module<a class="headerlink" href="#module-idtxl.idtxl_exceptions" title="Permalink to this headline">¶</a></h2>
<p>Provide error handling and warnings.</p>
<dl class="py exception">
<dt id="idtxl.idtxl_exceptions.AlgorithmExhaustedError">
<em class="property"><span class="pre">exception</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.idtxl_exceptions.</span></code><code class="sig-name descname"><span class="pre">AlgorithmExhaustedError</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">message</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_exceptions.html#AlgorithmExhaustedError"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_exceptions.AlgorithmExhaustedError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
<p>Exception raised to signal that the estimators can no longer be used
for this particular target (e.g. because of memory errors in high
dimensions) but that the estimation could continue for others.</p>
<dl class="simple">
<dt>Attributes:</dt><dd><p>message – explanation of the error</p>
</dd>
</dl>
</dd></dl>

<dl class="py exception">
<dt id="idtxl.idtxl_exceptions.BROJA_2PID_Exception">
<em class="property"><span class="pre">exception</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.idtxl_exceptions.</span></code><code class="sig-name descname"><span class="pre">BROJA_2PID_Exception</span></code><a class="reference internal" href="_modules/idtxl/idtxl_exceptions.html#BROJA_2PID_Exception"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_exceptions.BROJA_2PID_Exception" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
</dd></dl>

<dl class="py exception">
<dt id="idtxl.idtxl_exceptions.JidtOutOfMemoryError">
<em class="property"><span class="pre">exception</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.idtxl_exceptions.</span></code><code class="sig-name descname"><span class="pre">JidtOutOfMemoryError</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">message</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_exceptions.html#JidtOutOfMemoryError"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_exceptions.JidtOutOfMemoryError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.idtxl_exceptions.AlgorithmExhaustedError" title="idtxl.idtxl_exceptions.AlgorithmExhaustedError"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.idtxl_exceptions.AlgorithmExhaustedError</span></code></a></p>
<dl class="simple">
<dt>Exception raised to signal a Java OutOfMemoryException.</dt><dd><p>It is a child class of AlgorithmExhaustedError.</p>
</dd>
<dt>Attributes:</dt><dd><p>message – explanation of the error</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="idtxl.idtxl_exceptions.package_missing">
<code class="sig-prename descclassname"><span class="pre">idtxl.idtxl_exceptions.</span></code><code class="sig-name descname"><span class="pre">package_missing</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">err</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">message</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_exceptions.html#package_missing"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_exceptions.package_missing" title="Permalink to this definition">¶</a></dt>
<dd><p>Report a missing optional package upon import.</p>
</dd></dl>

</div>
<div class="section" id="module-idtxl.idtxl_io">
<span id="idtxl-idtxl-io-module"></span><h2>idtxl.idtxl_io module<a class="headerlink" href="#module-idtxl.idtxl_io" title="Permalink to this headline">¶</a></h2>
<p>Provide I/O functionality.</p>
<p>Provide functions to load and save IDTxl data, provide import functions (e.g.,
mat-files, FieldTrip) and export functions (e.g., networkx, BrainNet Viewer).</p>
<dl class="py function">
<dt id="idtxl.idtxl_io.export_brain_net_viewer">
<code class="sig-prename descclassname"><span class="pre">idtxl.idtxl_io.</span></code><code class="sig-name descname"><span class="pre">export_brain_net_viewer</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adjacency_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mni_coord</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_io.html#export_brain_net_viewer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_io.export_brain_net_viewer" title="Permalink to this definition">¶</a></dt>
<dd><p>Export network to BrainNet Viewer.</p>
<p>Export networks to BrainNet Viewer (project home page:
<a class="reference external" href="http://www.nitrc.org/projects/bnv/">http://www.nitrc.org/projects/bnv/</a>). BrainNet Viewer is a MATLAB
toolbox offering brain network visualisation (e.g., ‘glass’ brains).
The function creates text files [file_name].node and [file_name].edge,
containing information on node location (in MNI coordinates), directed
edges, node color and size.</p>
<p>References:</p>
<ul class="simple">
<li><p>Xia, M., Wang, J., &amp; He, Y. (2013). BrainNet Viewer: A Network
Visualization Tool for Human Brain Connectomics. PLoS ONE 8(7):e68910.
<a class="reference external" href="https://doi.org/10.1371/journal.pone.0068910">https://doi.org/10.1371/journal.pone.0068910</a></p></li>
</ul>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>adjacency_matrix<span class="classifier">AdjacencyMatrix instance</span></dt><dd><p>adjacency matrix to be exported, returned by get_adjacency_matrix()
method of Results() class</p>
</dd>
<dt>mni_coord<span class="classifier">numpy array</span></dt><dd><p>MNI coordinates (x,y,z) of the sources, array with size [n 3],
where n is the number of nodes</p>
</dd>
<dt>file_name<span class="classifier">str</span></dt><dd><p>file name for output files including the file path</p>
</dd>
<dt>labels<span class="classifier">array type of str [optional]</span></dt><dd><p>list of node labels of length n, description or label for each
node. Note that labels can’t contain spaces (causes BrainNet to
crash), the function will remove any spaces from labels
(default=no labels)</p>
</dd>
<dt>node_color<span class="classifier">array type of colors [optional]</span></dt><dd><p>BrainNet gives you the option to color nodes according to the
values in this vector (length n), see BrainNet Manual</p>
</dd>
<dt>node_size<span class="classifier">array type of int [optional]</span></dt><dd><p>BrainNet gives you the option to size nodes according to the
values in this array (length n), see BrainNet Manual</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="idtxl.idtxl_io.export_networkx_graph">
<code class="sig-prename descclassname"><span class="pre">idtxl.idtxl_io.</span></code><code class="sig-name descname"><span class="pre">export_networkx_graph</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adjacency_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_io.html#export_networkx_graph"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_io.export_networkx_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Export networkx graph object for an inferred network.</p>
<p>Export a weighted, directed graph object from the network of inferred
(multivariate) interactions (e.g., multivariate TE), using the networkx
class for directed graphs (DiGraph). Multiple options for the weight are
available (see documentation of method get_adjacency_matrix for details).</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>adjacency_matrix<span class="classifier">AdjacencyMatrix instances</span></dt><dd><p>adjacency matrix to be exported, returned by get_adjacency_matrix()
method of Results() class</p>
</dd>
<dt>weights<span class="classifier">str</span></dt><dd><p>weights for the adjacency matrix (see documentation of method
get_adjacency_matrix for details)</p>
</dd>
<dt>fdr<span class="classifier">bool [optional]</span></dt><dd><p>return FDR-corrected results (default=True)</p>
</dd>
</dl>
</dd>
<dt>Returns: DiGraph instance</dt><dd><p>directed graph of networkx package’s DiGraph() class</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="idtxl.idtxl_io.export_networkx_source_graph">
<code class="sig-prename descclassname"><span class="pre">idtxl.idtxl_io.</span></code><code class="sig-name descname"><span class="pre">export_networkx_source_graph</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">results</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sign_sources</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fdr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_io.html#export_networkx_source_graph"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_io.export_networkx_source_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Export graph object of source variables for a single target.</p>
<p>Export graph object from the network of (multivariate) interactions (e.g.,
multivariate TE) between single source variables and a target process using
the networkx class for directed graphs (DiGraph). The graph shows the
information transfer between individual source variables and the target.
Each node is a tuple with the following format:
(process index, sample index).</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>results<span class="classifier">Results() instance</span></dt><dd><p>network analysis results</p>
</dd>
<dt>target<span class="classifier">int</span></dt><dd><p>target index</p>
</dd>
<dt>sign_sources<span class="classifier">bool [optional]</span></dt><dd><p>add sources with significant information contribution only
(default=True)</p>
</dd>
<dt>fdr<span class="classifier">bool [optional]</span></dt><dd><p>return FDR-corrected results (default=True)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>DiGraph instance</dt><dd><p>directed graph of networkx package’s DiGraph() class</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="idtxl.idtxl_io.import_fieldtrip">
<code class="sig-prename descclassname"><span class="pre">idtxl.idtxl_io.</span></code><code class="sig-name descname"><span class="pre">import_fieldtrip</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ft_struct_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_version</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_io.html#import_fieldtrip"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_io.import_fieldtrip" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert FieldTrip-style MATLAB-file into an IDTxl Data object.</p>
<p>Import a MATLAB structure with fields  “trial” (data), “label” (channel
labels), “time” (time stamps for data samples), and “fsample” (sampling
rate). This structure is the standard file format in the MATLAB toolbox
FieldTrip and commonly use to represent neurophysiological data (see also
<a class="reference external" href="http://www.fieldtriptoolbox.org/reference/ft_datatype_raw">http://www.fieldtriptoolbox.org/reference/ft_datatype_raw</a>). The data is
returned as a IDTxl Data() object.</p>
<p>The structure is assumed to be saved as a matlab hdf5 file (“-v7.3’ or
higher, .mat) with a SINGLE FieldTrip data structure inside.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>file_name<span class="classifier">string</span></dt><dd><p>full (matlab) file_name on disk</p>
</dd>
<dt>ft_struct_name<span class="classifier">string</span></dt><dd><p>variable name of the MATLAB structure that is in FieldTrip format
(autodetect will hopefully be possible later …)</p>
</dd>
<dt>file_version<span class="classifier">string</span></dt><dd><p>version of the file, e.g. ‘v7.3’ for MATLAB’s 7.3 format</p>
</dd>
<dt>normalise<span class="classifier">bool [optional]</span></dt><dd><p>normalise data after import (default=True)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>Data() instance</dt><dd><p>instance of IDTxl Data object, containing data from the ‘trial’
field</p>
</dd>
<dt>list of strings</dt><dd><p>list of channel labels, corresponding to the ‘label’ field</p>
</dd>
<dt>numpy array</dt><dd><p>time stamps for samples, corresponding to one entry in the ‘time’
field</p>
</dd>
<dt>int</dt><dd><p>sampling rate, corresponding to the ‘fsample’ field</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="idtxl.idtxl_io.import_matarray">
<code class="sig-prename descclassname"><span class="pre">idtxl.idtxl_io.</span></code><code class="sig-name descname"><span class="pre">import_matarray</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">array_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_version</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_io.html#import_matarray"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_io.import_matarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Read Matlab hdf5 file into IDTxl.</p>
<p>reads a matlab hdf5 file (“-v7.3’ or higher, .mat) or non-hdf5 files with a
SINGLE array inside and returns an IDTxl Data() object.</p>
<dl class="simple">
<dt>Note:</dt><dd><p>The import function squeezes the loaded mat-file, i.e., any singleton
dimension will be removed. Hence do not enter singleton dimension into
the ‘dim_order’, e.g., don’t pass dim_order=’ps’ but dim_order=’s‘ if
you want to load a 1D-array where entries represent samples recorded
from a single channel.</p>
</dd>
<dt>Args:</dt><dd><dl class="simple">
<dt>file_name<span class="classifier">string</span></dt><dd><p>full (matlab) file_name on disk</p>
</dd>
<dt>array_name<span class="classifier">string</span></dt><dd><p>variable name of the MATLAB structure to be read</p>
</dd>
<dt>file_version<span class="classifier">string</span></dt><dd><p>version of the file, e.g. ‘v7.3’ for MATLAB’s 7.3 format, currently
versions ‘v4’, ‘v6’, ‘v7’, and ‘v7’ are supported</p>
</dd>
<dt>dim_order<span class="classifier">string</span></dt><dd><p>order of dimensions, accepts any combination of the characters
‘p’, ‘s’, and ‘r’ for processes, samples, and replications; must
have the same length as the data dimensionality, e.g., ‘ps’ for a
two-dimensional array of data from several processes over time</p>
</dd>
<dt>normalise<span class="classifier">bool [optional]</span></dt><dd><p>normalise data after import (default=True)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>Data() instance</dt><dd><p>instance of IDTxl Data object, containing data from the ‘trial’
field</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="idtxl.idtxl_io.load_json">
<code class="sig-prename descclassname"><span class="pre">idtxl.idtxl_io.</span></code><code class="sig-name descname"><span class="pre">load_json</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_io.html#load_json"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_io.load_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Load dictionary saved as JSON file from disk.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>file_path<span class="classifier">str</span></dt><dd><p>path to file (including extension)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>dict</p>
</dd>
</dl>
<p>Note: JSON does not recognize numpy data structures and types. Numpy arrays
and data types (float, int) are thus converted to Python types and lists.
The loaded dictionary may thus contain different data types than the saved
one.</p>
</dd></dl>

<dl class="py function">
<dt id="idtxl.idtxl_io.load_pickle">
<code class="sig-prename descclassname"><span class="pre">idtxl.idtxl_io.</span></code><code class="sig-name descname"><span class="pre">load_pickle</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_io.html#load_pickle"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_io.load_pickle" title="Permalink to this definition">¶</a></dt>
<dd><p>Load objects that have been saved using Python’s pickle module.</p>
</dd></dl>

<dl class="py function">
<dt id="idtxl.idtxl_io.save_json">
<code class="sig-prename descclassname"><span class="pre">idtxl.idtxl_io.</span></code><code class="sig-name descname"><span class="pre">save_json</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_io.html#save_json"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_io.save_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Save dictionary to disk as JSON file.</p>
<p>Writes dictionary to disk at the specified file path.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>d<span class="classifier">dict</span></dt><dd><p>dictionary to be written to disk</p>
</dd>
<dt>file_path<span class="classifier">str</span></dt><dd><p>path to file (including extension)</p>
</dd>
</dl>
</dd>
</dl>
<p>Note: JSON does not recognize numpy data types, those are converted to
basic Python data types first.</p>
</dd></dl>

<dl class="py function">
<dt id="idtxl.idtxl_io.save_pickle">
<code class="sig-prename descclassname"><span class="pre">idtxl.idtxl_io.</span></code><code class="sig-name descname"><span class="pre">save_pickle</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_io.html#save_pickle"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_io.save_pickle" title="Permalink to this definition">¶</a></dt>
<dd><p>Save objects using Python’s pickle module.</p>
<dl class="simple">
<dt>Note:</dt><dd><p>pickle.HIGHEST_PROTOCOL is a binary format, which may be inconvenient,
but is good for performance. Protocol 0 is a text format.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-idtxl.idtxl_utils">
<span id="idtxl-idtxl-utils-module"></span><h2>idtxl.idtxl_utils module<a class="headerlink" href="#module-idtxl.idtxl_utils" title="Permalink to this headline">¶</a></h2>
<p>Provide IDTxl utility functions.</p>
<dl class="py function">
<dt id="idtxl.idtxl_utils.argsort_descending">
<code class="sig-prename descclassname"><span class="pre">idtxl.idtxl_utils.</span></code><code class="sig-name descname"><span class="pre">argsort_descending</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#argsort_descending"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_utils.argsort_descending" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort array in descending order and return sortind indices.</p>
</dd></dl>

<dl class="py function">
<dt id="idtxl.idtxl_utils.autocorrelation">
<code class="sig-prename descclassname"><span class="pre">idtxl.idtxl_utils.</span></code><code class="sig-name descname"><span class="pre">autocorrelation</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#autocorrelation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_utils.autocorrelation" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate autocorrelation of a vector.</p>
</dd></dl>

<dl class="py function">
<dt id="idtxl.idtxl_utils.calculate_mi">
<code class="sig-prename descclassname"><span class="pre">idtxl.idtxl_utils.</span></code><code class="sig-name descname"><span class="pre">calculate_mi</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">corr</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#calculate_mi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_utils.calculate_mi" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate mutual information from correlation coefficient.</p>
</dd></dl>

<dl class="py function">
<dt id="idtxl.idtxl_utils.combine_discrete_dimensions">
<code class="sig-prename descclassname"><span class="pre">idtxl.idtxl_utils.</span></code><code class="sig-name descname"><span class="pre">combine_discrete_dimensions</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numBins</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#combine_discrete_dimensions"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_utils.combine_discrete_dimensions" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine multi-dimensional discrete variable into a single dimension.</p>
<p>Combine all dimensions for a discrete variable down into a single
dimensional value for each sample. This is done basically by multiplying
each dimension by a different power of the base (numBins).</p>
<p>Adapted from infodynamics.utils.MatrixUtils.computeCombinedValues() from
JIDT by J.Lizier.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>a<span class="classifier">numpy array</span></dt><dd><p>data to be combined across all variable dimensions. Dimensions are
realisations (samples) x variable dimension</p>
</dd>
<dt>numBins<span class="classifier">int</span></dt><dd><p>number of discrete levels or bins for each variable dimension</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>numpy array</dt><dd><p>a univariate array – one entry now for each sample,
with all dimensions of the data now combined for that sample</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="idtxl.idtxl_utils.conflicting_entries">
<code class="sig-prename descclassname"><span class="pre">idtxl.idtxl_utils.</span></code><code class="sig-name descname"><span class="pre">conflicting_entries</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dict_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dict_2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#conflicting_entries"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_utils.conflicting_entries" title="Permalink to this definition">¶</a></dt>
<dd><p>Test two dictionaries for unequal entries.</p>
<p>Note that only keys that are present in both dicts are compared. If one
dictionary contains an entry not present in the other dictionary, the
test passes.</p>
</dd></dl>

<dl class="py function">
<dt id="idtxl.idtxl_utils.discretise">
<code class="sig-prename descclassname"><span class="pre">idtxl.idtxl_utils.</span></code><code class="sig-name descname"><span class="pre">discretise</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numBins</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#discretise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_utils.discretise" title="Permalink to this definition">¶</a></dt>
<dd><p>Discretise continuous data.</p>
<p>Discretise continuous data into discrete values (with 0 as lowest) by
evenly partitioning the range of the data, one dimension at a time.
Adapted from infodynamics.utils.MatrixUtils.discretise() from JIDT by
J. Lizier.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>a<span class="classifier">numpy array</span></dt><dd><p>data to be discretised. Dimensions are
realisations x variable dimension</p>
</dd>
<dt>numBins<span class="classifier">int</span></dt><dd><p>number of discrete levels or bins to partition the data into</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>numpy array</dt><dd><p>discretised data</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="idtxl.idtxl_utils.discretise_max_ent">
<code class="sig-prename descclassname"><span class="pre">idtxl.idtxl_utils.</span></code><code class="sig-name descname"><span class="pre">discretise_max_ent</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numBins</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#discretise_max_ent"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_utils.discretise_max_ent" title="Permalink to this definition">¶</a></dt>
<dd><p>Discretise continuous data using maximum entropy partitioning.</p>
<p>Discretise continuous data into discrete values (with 0 as lowest) by
making a maximum entropy partitioning, one dimension at a time. Adapted
from infodynamics.utils.MatrixUtils.discretiseMaxEntropy() from JIDT by
J. Lizier.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>a<span class="classifier">numpy array</span></dt><dd><p>data to be discretised. Dimensions are
realisations x variable dimension</p>
</dd>
<dt>numBins<span class="classifier">int</span></dt><dd><p>number of discrete levels or bins to partition the data into</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>numpy array</dt><dd><p>discretised data</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="idtxl.idtxl_utils.equal_dicts">
<code class="sig-prename descclassname"><span class="pre">idtxl.idtxl_utils.</span></code><code class="sig-name descname"><span class="pre">equal_dicts</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dict_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dict_2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#equal_dicts"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_utils.equal_dicts" title="Permalink to this definition">¶</a></dt>
<dd><p>Test two dictionaries for equality.</p>
</dd></dl>

<dl class="py function">
<dt id="idtxl.idtxl_utils.print_dict">
<code class="sig-prename descclassname"><span class="pre">idtxl.idtxl_utils.</span></code><code class="sig-name descname"><span class="pre">print_dict</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#print_dict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_utils.print_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Use Python’s pretty printer to print dictionaries to the console.</p>
</dd></dl>

<dl class="py function">
<dt id="idtxl.idtxl_utils.remove_column">
<code class="sig-prename descclassname"><span class="pre">idtxl.idtxl_utils.</span></code><code class="sig-name descname"><span class="pre">remove_column</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#remove_column"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_utils.remove_column" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a column from a numpy array.</p>
<p>This is faster than logical indexing (‘25 times faster’), because it does
not make copies, see
<a class="reference external" href="http://scipy.github.io/old-wiki/pages/PerformanceTips">http://scipy.github.io/old-wiki/pages/PerformanceTips</a></p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>a<span class="classifier">numpy array</span></dt><dd><p>2-dimensional numpy array</p>
</dd>
<dt>i<span class="classifier">int</span></dt><dd><p>column index to be removed</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="idtxl.idtxl_utils.remove_row">
<code class="sig-prename descclassname"><span class="pre">idtxl.idtxl_utils.</span></code><code class="sig-name descname"><span class="pre">remove_row</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#remove_row"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_utils.remove_row" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a row from a numpy array.</p>
<p>This is faster than logical indexing (‘25 times faster’), because it does
not make copies, see
<a class="reference external" href="http://scipy.github.io/old-wiki/pages/PerformanceTips">http://scipy.github.io/old-wiki/pages/PerformanceTips</a></p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>a<span class="classifier">numpy array</span></dt><dd><p>2-dimensional numpy array</p>
</dd>
<dt>i<span class="classifier">int</span></dt><dd><p>row index to be removed</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="idtxl.idtxl_utils.separate_arrays">
<code class="sig-prename descclassname"><span class="pre">idtxl.idtxl_utils.</span></code><code class="sig-name descname"><span class="pre">separate_arrays</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">idx_all</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_single</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#separate_arrays"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_utils.separate_arrays" title="Permalink to this definition">¶</a></dt>
<dd><p>Separate a single column from all other columns in a 2D-array.</p>
<p>Return the separated single column and the remaining columns of a 2D-
array.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>idx_all<span class="classifier">list&lt;Object&gt;</span></dt><dd><p>list of variables indicating the full set</p>
</dd>
<dt>idx_single<span class="classifier">&lt;Object&gt;</span></dt><dd><p>single variable indicating the column to be separated, variable
must be contained in idx_all</p>
</dd>
<dt>a<span class="classifier">numpy array</span></dt><dd><p>2D-array with the same length along axis 1 as idx_all
(.shape[1] == len(idx_all))</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>numpy array</dt><dd><p>remaining columns in full array</p>
</dd>
<dt>numpy array</dt><dd><p>column at single index</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="idtxl.idtxl_utils.sort_descending">
<code class="sig-prename descclassname"><span class="pre">idtxl.idtxl_utils.</span></code><code class="sig-name descname"><span class="pre">sort_descending</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#sort_descending"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_utils.sort_descending" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort array in descending order.</p>
</dd></dl>

<dl class="py function">
<dt id="idtxl.idtxl_utils.standardise">
<code class="sig-prename descclassname"><span class="pre">idtxl.idtxl_utils.</span></code><code class="sig-name descname"><span class="pre">standardise</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">df</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#standardise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_utils.standardise" title="Permalink to this definition">¶</a></dt>
<dd><p>Z-standardise a numpy array along a given dimension.</p>
<p>Standardise array along the axis defined in dimension using the denominator
(N - df) for the calculation of the standard deviation.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>a<span class="classifier">numpy array</span></dt><dd><p>data to be standardised</p>
</dd>
<dt>dimension<span class="classifier">int [optional]</span></dt><dd><p>dimension along which array should be standardised</p>
</dd>
<dt>df<span class="classifier">int [optional]</span></dt><dd><p>degrees of freedom for the denominator of the standard derivation</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>numpy array</dt><dd><p>standardised data</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="idtxl.idtxl_utils.swap_chars">
<code class="sig-prename descclassname"><span class="pre">idtxl.idtxl_utils.</span></code><code class="sig-name descname"><span class="pre">swap_chars</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i_2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#swap_chars"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.idtxl_utils.swap_chars" title="Permalink to this definition">¶</a></dt>
<dd><p>Swap to characters in a string.</p>
<dl>
<dt>Example:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">swap_chars</span><span class="p">(</span><span class="s1">&#39;heLlotHere&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="go">&#39;heHlotLere&#39;</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-idtxl.network_analysis">
<span id="idtxl-network-analysis-module"></span><h2>idtxl.network_analysis module<a class="headerlink" href="#module-idtxl.network_analysis" title="Permalink to this headline">¶</a></h2>
<p>Parent class for network inference and network comparison.</p>
<dl class="py class">
<dt id="idtxl.network_analysis.NetworkAnalysis">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.network_analysis.</span></code><code class="sig-name descname"><span class="pre">NetworkAnalysis</span></code><a class="reference internal" href="_modules/idtxl/network_analysis.html#NetworkAnalysis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.network_analysis.NetworkAnalysis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Provide an analysis setup for network inference or comparison.</p>
<p>The class provides routines to check user input and set defaults.</p>
<dl class="py method">
<dt id="idtxl.network_analysis.NetworkAnalysis.current_value">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">current_value</span></code><a class="headerlink" href="#idtxl.network_analysis.NetworkAnalysis.current_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Get index of the current_value.</p>
</dd></dl>

<dl class="py method">
<dt id="idtxl.network_analysis.NetworkAnalysis.resume_checkpoint">
<code class="sig-name descname"><span class="pre">resume_checkpoint</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/network_analysis.html#NetworkAnalysis.resume_checkpoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.network_analysis.NetworkAnalysis.resume_checkpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Resume analysis from a checkpoint saved to disk.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>file_path<span class="classifier">str</span></dt><dd><p>path to checkpoint file (excluding extension: <a href="#id1"><span class="problematic" id="id2">*</span></a>.ckp)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.network_analysis.NetworkAnalysis.selected_vars_full">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">selected_vars_full</span></code><a class="headerlink" href="#idtxl.network_analysis.NetworkAnalysis.selected_vars_full" title="Permalink to this definition">¶</a></dt>
<dd><p>List of indices of the full conditional set.</p>
</dd></dl>

<dl class="py method">
<dt id="idtxl.network_analysis.NetworkAnalysis.selected_vars_sources">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">selected_vars_sources</span></code><a class="headerlink" href="#idtxl.network_analysis.NetworkAnalysis.selected_vars_sources" title="Permalink to this definition">¶</a></dt>
<dd><p>List of indices of source samples in the conditional set.</p>
</dd></dl>

<dl class="py method">
<dt id="idtxl.network_analysis.NetworkAnalysis.selected_vars_target">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">selected_vars_target</span></code><a class="headerlink" href="#idtxl.network_analysis.NetworkAnalysis.selected_vars_target" title="Permalink to this definition">¶</a></dt>
<dd><p>List of indices of target samples in the conditional set.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-idtxl.network_inference">
<span id="idtxl-network-inference-module"></span><h2>idtxl.network_inference module<a class="headerlink" href="#module-idtxl.network_inference" title="Permalink to this headline">¶</a></h2>
<p>Parent class for all network inference.</p>
<dl class="py class">
<dt id="idtxl.network_inference.NetworkInference">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.network_inference.</span></code><code class="sig-name descname"><span class="pre">NetworkInference</span></code><a class="reference internal" href="_modules/idtxl/network_inference.html#NetworkInference"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.network_inference.NetworkInference" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.network_analysis.NetworkAnalysis" title="idtxl.network_analysis.NetworkAnalysis"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.network_analysis.NetworkAnalysis</span></code></a></p>
<p>Parent class for network inference algorithms.</p>
<p>Hold variables that are relevant for network inference using for example
bivariate and multivariate transfer entropy.</p>
<dl class="simple">
<dt>Attributes:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>settings for estimation of information theoretic measures and
statistical testing, see child classes for documentation</p>
</dd>
<dt>target<span class="classifier">int</span></dt><dd><p>target process of analysis</p>
</dd>
<dt>current_value<span class="classifier">tuple</span></dt><dd><p>index of the current value</p>
</dd>
<dt>selected_vars_full<span class="classifier">list of tuples</span></dt><dd><p>indices of the full set of random variables to be conditioned on</p>
</dd>
<dt>selected_vars_target<span class="classifier">list of tuples</span></dt><dd><p>indices of the set of conditionals coming from the target process</p>
</dd>
<dt>selected_vars_sources<span class="classifier">list of tuples</span></dt><dd><p>indices of the set of conditionals coming from source processes</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="idtxl.network_inference.NetworkInferenceBivariate">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.network_inference.</span></code><code class="sig-name descname"><span class="pre">NetworkInferenceBivariate</span></code><a class="reference internal" href="_modules/idtxl/network_inference.html#NetworkInferenceBivariate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.network_inference.NetworkInferenceBivariate" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.network_inference.NetworkInference" title="idtxl.network_inference.NetworkInference"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.network_inference.NetworkInference</span></code></a></p>
<p>Parent class for bivariate network inference algorithms.</p>
</dd></dl>

<dl class="py class">
<dt id="idtxl.network_inference.NetworkInferenceMI">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.network_inference.</span></code><code class="sig-name descname"><span class="pre">NetworkInferenceMI</span></code><a class="reference internal" href="_modules/idtxl/network_inference.html#NetworkInferenceMI"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.network_inference.NetworkInferenceMI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.network_inference.NetworkInference" title="idtxl.network_inference.NetworkInference"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.network_inference.NetworkInference</span></code></a></p>
<p>Parent class for mutual information network inference algorithms.</p>
</dd></dl>

<dl class="py class">
<dt id="idtxl.network_inference.NetworkInferenceMultivariate">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.network_inference.</span></code><code class="sig-name descname"><span class="pre">NetworkInferenceMultivariate</span></code><a class="reference internal" href="_modules/idtxl/network_inference.html#NetworkInferenceMultivariate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.network_inference.NetworkInferenceMultivariate" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.network_inference.NetworkInference" title="idtxl.network_inference.NetworkInference"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.network_inference.NetworkInference</span></code></a></p>
<p>Parent class for multivariate network inference algorithms.</p>
</dd></dl>

<dl class="py class">
<dt id="idtxl.network_inference.NetworkInferenceTE">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.network_inference.</span></code><code class="sig-name descname"><span class="pre">NetworkInferenceTE</span></code><a class="reference internal" href="_modules/idtxl/network_inference.html#NetworkInferenceTE"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.network_inference.NetworkInferenceTE" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.network_inference.NetworkInference" title="idtxl.network_inference.NetworkInference"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.network_inference.NetworkInference</span></code></a></p>
<p>Parent class for transfer entropy network inference algorithms.</p>
</dd></dl>

</div>
<div class="section" id="module-idtxl.single_process_analysis">
<span id="idtxl-single-process-analysis-module"></span><h2>idtxl.single_process_analysis module<a class="headerlink" href="#module-idtxl.single_process_analysis" title="Permalink to this headline">¶</a></h2>
<p>Parent class for analysis of single processes in the network.</p>
<dl class="py class">
<dt id="idtxl.single_process_analysis.SingleProcessAnalysis">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.single_process_analysis.</span></code><code class="sig-name descname"><span class="pre">SingleProcessAnalysis</span></code><a class="reference internal" href="_modules/idtxl/single_process_analysis.html#SingleProcessAnalysis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.single_process_analysis.SingleProcessAnalysis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.network_analysis.NetworkAnalysis" title="idtxl.network_analysis.NetworkAnalysis"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.network_analysis.NetworkAnalysis</span></code></a></p>
</dd></dl>

</div>
<div class="section" id="module-idtxl.network_comparison">
<span id="idtxl-network-comparison-module"></span><h2>idtxl.network_comparison module<a class="headerlink" href="#module-idtxl.network_comparison" title="Permalink to this headline">¶</a></h2>
<p>Perform inference statistics on groups of data.</p>
<dl class="py class">
<dt id="idtxl.network_comparison.NetworkComparison">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.network_comparison.</span></code><code class="sig-name descname"><span class="pre">NetworkComparison</span></code><a class="reference internal" href="_modules/idtxl/network_comparison.html#NetworkComparison"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.network_comparison.NetworkComparison" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.network_analysis.NetworkAnalysis" title="idtxl.network_analysis.NetworkAnalysis"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.network_analysis.NetworkAnalysis</span></code></a></p>
<p>Set up network comparison between two experimental conditions.</p>
<p>The class provides methods for the comparison of networks inferred from
data recorded under two experimental conditions A and B. Four statistical
tests are implemented:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 31%" />
<col style="width: 17%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>units of observation/
comparison type</p></th>
<th class="head"><p>stats_type</p></th>
<th class="head"><p>example</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td rowspan="2"><p>replications/
<strong>within</strong> a subject</p></td>
<td><p>dependent</p></td>
<td><p>base line (A) vs. task (B)</p></td>
</tr>
<tr class="row-odd"><td><p>independent</p></td>
<td><p>detect house (A) vs. face (B)</p></td>
</tr>
<tr class="row-even"><td rowspan="2"><p>sets of data/
<strong>between</strong> subjects</p></td>
<td><p>dependent</p></td>
<td><p>patients (A) vs. matched controls (B)</p></td>
</tr>
<tr class="row-odd"><td><p>independent</p></td>
<td><p>male (A) vs. female (B) participants</p></td>
</tr>
</tbody>
</table>
<p>Depending on the units of observations, one of two statistics methods can
be used: compare_within() and compare_between(). The stats_type is passed
as an analysis setting, see the documentation of the two methods for
details.</p>
<p>Note that for network inference methods that use an embedding, i.e., a
collection of variables in the source, the joint information in all
variables about the target is used as a test statistic.</p>
<dl class="py method">
<dt id="idtxl.network_comparison.NetworkComparison.calculate_link_te">
<code class="sig-name descname"><span class="pre">calculate_link_te</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sources</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/network_comparison.html#NetworkComparison.calculate_link_te"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.network_comparison.NetworkComparison.calculate_link_te" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the information transfer for whole links into a target.</p>
<p>Calculate the information transfer for whole links as the joint
information transfer from all variables selected for a single source
process into the target. The information transfer is calculated
conditional on the target’s past and, for multivariate TE, conditional
on selected variables from further sources in the network.</p>
<p>If sources is set to ‘all’, a list of information transfer values is
returned. If sources is set to a single source index, the information
transfer from this source to the target is returned.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data for analysis</p>
</dd>
<dt>target<span class="classifier">int</span></dt><dd><p>index of target process</p>
</dd>
<dt>sources<span class="classifier">list of ints | ‘all’ [optional]</span></dt><dd><p>return estimates for links from selected or all sources into
the target (default=’all’)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>numpy array</dt><dd><p>information transfer estimate for each link</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.network_comparison.NetworkComparison.compare_between">
<code class="sig-name descname"><span class="pre">compare_between</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">network_set_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">network_set_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_set_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_set_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/network_comparison.html#NetworkComparison.compare_between"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.network_comparison.NetworkComparison.compare_between" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare networks inferred under two conditions between subjects.</p>
<p>Compare two sets of networks inferred from two sets of data recorded
under different experimental conditions within multiple subjects, i.e.,
data have been recorded from subjects assigned to one of two
experimental conditions (units of observations are subjects).</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>parameters for estimation and statistical testing, see
documentation of compare_within() for details</p>
</dd>
<dt>network_set_a<span class="classifier">numpy array of dicts</span></dt><dd><p>results from network inference for multiple subjects observed
under condition a</p>
</dd>
<dt>network_set_b<span class="classifier">numpy array of dicts</span></dt><dd><p>results from network inference for multiple subjects observed
under condition b</p>
</dd>
<dt>data_a<span class="classifier">numpy array of Data objects</span></dt><dd><p>set of data from which network_set_a was inferred</p>
</dd>
<dt>data_b<span class="classifier">numpy array of Data objects</span></dt><dd><p>set of data from which network_set_b was inferred</p>
</dd>
</dl>
</dd>
<dt>Returns</dt><dd><dl class="simple">
<dt>ResultsNetworkComparison object</dt><dd><p>results of network inference, see documentation of
ResultsNetworkComparison()</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.network_comparison.NetworkComparison.compare_links_within">
<code class="sig-name descname"><span class="pre">compare_links_within</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">link_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">link_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">network</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/network_comparison.html#NetworkComparison.compare_links_within"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.network_comparison.NetworkComparison.compare_links_within" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two links within the same network.</p>
<p>Compare two links within the same network. Check if information
transfer is different from information transfer in a second link.</p>
<p>Note that both links have to be part of the inferred network, i.e.,
there has to be significant effective connectivity for both links.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>parameters for estimation and statistical testing</p>
<ul class="simple">
<li><p>stats_type : str - ‘dependent’ or ‘independent’ for
dependent or independent units of observation</p></li>
<li><p>cmi_estimator : str - estimator to be used for CMI
calculation (for estimator settings see the documentation in
the estimators_* modules)</p></li>
<li><p>tail_comp : str [optional] - test tail, ‘one’ for one-sided
test A &gt; B, ‘two’ for two-sided test (default=’two’)</p></li>
<li><p>n_perm_comp : int [optional] - number of permutations
(default=500)</p></li>
<li><p>alpha_comp : float - critical alpha level for statistical
significance (default=0.05)</p></li>
<li><p>permute_in_time : bool [optional] - if True, create
surrogates by shuffling data over time. See
Data.permute_samples() for settings for further options for
surrogate creation</p></li>
<li><p>verbose : bool [optional] - toggle console output
(default=True)</p></li>
</ul>
</dd>
<dt>link_a<span class="classifier">array type</span></dt><dd><p>first link, array type with two entries [source target]</p>
</dd>
<dt>link_b<span class="classifier">array type</span></dt><dd><p>second link, array type with two entries [source target]</p>
</dd>
<dt>network<span class="classifier">dict</span></dt><dd><p>results from network inference</p>
</dd>
<dt>data<span class="classifier">Data object</span></dt><dd><p>data from which network was inferred</p>
</dd>
</dl>
</dd>
<dt>Returns</dt><dd><dl class="simple">
<dt>ResultsNetworkComparison object</dt><dd><p>results of network inference, see documentation of
ResultsNetworkComparison()</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.network_comparison.NetworkComparison.compare_within">
<code class="sig-name descname"><span class="pre">compare_within</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">network_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">network_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/network_comparison.html#NetworkComparison.compare_within"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.network_comparison.NetworkComparison.compare_within" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare networks inferred under two conditions within one subject.</p>
<p>Compare two networks inferred from data recorded under two different
experimental conditions within one subject (units of observations are
replications of one experimental condition within one subject).</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict</span></dt><dd><p>parameters for estimation and statistical testing</p>
<ul class="simple">
<li><p>stats_type : str - ‘dependent’ or ‘independent’ for
dependent or independent units of observation</p></li>
<li><p>cmi_estimator : str - estimator to be used for CMI
calculation (for estimator settings see the documentation in
the estimators_* modules)</p></li>
<li><p>tail_comp : str [optional] - test tail, ‘one’ for one-sided
test A &gt; B, ‘two’ for two-sided test (default=’two’)</p></li>
<li><p>n_perm_comp : int [optional] - number of permutations
(default=500)</p></li>
<li><p>alpha_comp : float - critical alpha level for statistical
significance (default=0.05)</p></li>
<li><p>permute_in_time : bool [optional] - if True, create
surrogates by shuffling data over time. See
Data.permute_samples() for settings for further options for
surrogate creation</p></li>
<li><p>verbose : bool [optional] - toggle console output
(default=True)</p></li>
</ul>
</dd>
<dt>network_a<span class="classifier">dict</span></dt><dd><p>results from network inference, condition a</p>
</dd>
<dt>network_b<span class="classifier">dict</span></dt><dd><p>results from network inference, condition b</p>
</dd>
<dt>data_a<span class="classifier">Data object</span></dt><dd><p>data from which network_a was inferred</p>
</dd>
<dt>data_b<span class="classifier">Data object</span></dt><dd><p>data from which network_b was inferred</p>
</dd>
</dl>
</dd>
<dt>Returns</dt><dd><dl class="simple">
<dt>ResultsNetworkComparison object</dt><dd><p>results of network inference, see documentation of
ResultsNetworkComparison()</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-idtxl.results">
<span id="idtxl-results-module"></span><h2>idtxl.results module<a class="headerlink" href="#module-idtxl.results" title="Permalink to this headline">¶</a></h2>
<p>Provide results class for IDTxl network analysis.</p>
<dl class="py class">
<dt id="idtxl.results.AdjacencyMatrix">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.results.</span></code><code class="sig-name descname"><span class="pre">AdjacencyMatrix</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_nodes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_type</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#AdjacencyMatrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.AdjacencyMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Adjacency matrix representing inferred networks.</p>
<dl class="py method">
<dt id="idtxl.results.AdjacencyMatrix.add_edge">
<code class="sig-name descname"><span class="pre">add_edge</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#AdjacencyMatrix.add_edge"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.AdjacencyMatrix.add_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Add weighted edge (i, j) to adjacency matrix.</p>
</dd></dl>

<dl class="py method">
<dt id="idtxl.results.AdjacencyMatrix.add_edge_list">
<code class="sig-name descname"><span class="pre">add_edge_list</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#AdjacencyMatrix.add_edge_list"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.AdjacencyMatrix.add_edge_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Add multiple weighted edges (i, j) to adjacency matrix.</p>
</dd></dl>

<dl class="py method">
<dt id="idtxl.results.AdjacencyMatrix.get_edge_list">
<code class="sig-name descname"><span class="pre">get_edge_list</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#AdjacencyMatrix.get_edge_list"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.AdjacencyMatrix.get_edge_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Return list of weighted edges.</p>
<dl class="simple">
<dt>Returns</dt><dd><dl class="simple">
<dt>list of tuples</dt><dd><p>each entry represents one edge in the graph: (i, j, weight)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.results.AdjacencyMatrix.n_edges">
<code class="sig-name descname"><span class="pre">n_edges</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#AdjacencyMatrix.n_edges"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.AdjacencyMatrix.n_edges" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="idtxl.results.AdjacencyMatrix.n_nodes">
<code class="sig-name descname"><span class="pre">n_nodes</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#AdjacencyMatrix.n_nodes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.AdjacencyMatrix.n_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of nodes.</p>
</dd></dl>

<dl class="py method">
<dt id="idtxl.results.AdjacencyMatrix.print_matrix">
<code class="sig-name descname"><span class="pre">print_matrix</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#AdjacencyMatrix.print_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.AdjacencyMatrix.print_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Print weight and edge matrix.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="idtxl.results.DotDict">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.results.</span></code><code class="sig-name descname"><span class="pre">DotDict</span></code><a class="reference internal" href="_modules/idtxl/results.html#DotDict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.DotDict" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></p>
<p>Dictionary with dot-notation access to values.</p>
<p>Provides the same functionality as a regular dict, but also allows
accessing values using dot-notation.</p>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">idtxl.results</span> <span class="k">import</span> <span class="n">DotDict</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">DotDict</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Out: 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Out: 1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt id="idtxl.results.Results">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.results.</span></code><code class="sig-name descname"><span class="pre">Results</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_nodes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_realisations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalised</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#Results"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.Results" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Parent class for results of network analysis algorithms.</p>
<p>Provide a container for results of network analysis algorithms, e.g.,
MultivariateTE or ActiveInformationStorage.</p>
<dl>
<dt>Attributes:</dt><dd><dl>
<dt>settings<span class="classifier">dict</span></dt><dd><p>settings used for estimation of information theoretic measures and
statistical testing</p>
</dd>
<dt>data_properties<span class="classifier">dict</span></dt><dd><p>data properties, contains</p>
<blockquote>
<div><ul class="simple">
<li><p>n_nodes : int - total number of nodes in the network</p></li>
<li><p>n_realisations : int - number of samples available for
analysis given the settings (e.g., a high maximum lag used in
network inference, results in fewer data points available for
estimation)</p></li>
<li><p>normalised : bool - indicates if data were z-standardised
before the estimation</p></li>
</ul>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="idtxl.results.Results.combine_results">
<code class="sig-name descname"><span class="pre">combine_results</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">results</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#Results.combine_results"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.Results.combine_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine multiple (partial) results objects.</p>
<p>Combine a list of partial network analysis results into a single
results object (e.g., results from analysis parallelized over
processes). Raise an error if duplicate processes occur in partial
results, or if analysis settings are not equal.</p>
<p>Note that only conflicting settings cause an error (i.e., settings with
equal keys but different values). If additional settings are included
in partial results (i.e., settings with different keys) these settings
are added to the common settings dictionary.</p>
<p>Remove FDR-corrections from partial results before combining them. FDR-
correction performed on the basis of parts of the network is not valid
for the combined network.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>results<span class="classifier">list of Results objects</span></dt><dd><p>single process analysis results from .analyse_network or
.analyse_single_process methods, where each object contains
partial results for one or multiple processes</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>dict</dt><dd><p>combined results object</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="idtxl.results.ResultsMultivariatePID">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.results.</span></code><code class="sig-name descname"><span class="pre">ResultsMultivariatePID</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_nodes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_realisations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalised</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#ResultsMultivariatePID"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.ResultsMultivariatePID" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.results.ResultsNetworkAnalysis" title="idtxl.results.ResultsNetworkAnalysis"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.results.ResultsNetworkAnalysis</span></code></a></p>
<p>Store results of Multivariate Partial Information Decomposition (PID)
analysis.</p>
<blockquote>
<div><p>Provide a container for results of Multivariate Partial Information
Decomposition (PID) algorithms.</p>
<p>Note that for convenience all dictionaries in this class can additionally
be accessed using dot-notation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res_pid</span><span class="o">.</span><span class="n">_single_target</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">source_1</span>
</pre></div>
</div>
<p>or</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res_pid</span><span class="o">.</span><span class="n">_single_target</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="p">[</span><span class="s1">&#39;source_1&#39;</span><span class="p">]</span><span class="o">.</span>
</pre></div>
</div>
<dl>
<dt>Attributes:</dt><dd><dl>
<dt>settings<span class="classifier">dict</span></dt><dd><p>settings used for estimation of information theoretic measures and
statistical testing</p>
</dd>
<dt>data_properties<span class="classifier">dict</span></dt><dd><p>data properties, contains</p>
<blockquote>
<div><ul class="simple">
<li><p>n_nodes : int - total number of nodes in the network</p></li>
<li><p>n_realisations : int - number of samples available for
analysis given the settings (e.g., a high maximum lag used in
network inference, results in fewer data points available for
estimation)</p></li>
<li><p>normalised : bool - indicates if data were z-standardised
before the estimation</p></li>
</ul>
</div></blockquote>
</dd>
<dt>targets_analysed<span class="classifier">list</span></dt><dd><p>list of analysed targets</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<dl class="py method">
<dt id="idtxl.results.ResultsMultivariatePID.get_single_target">
<code class="sig-name descname"><span class="pre">get_single_target</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#ResultsMultivariatePID.get_single_target"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.ResultsMultivariatePID.get_single_target" title="Permalink to this definition">¶</a></dt>
<dd><p>Return results for a single target in the network.</p>
<p>Results for single targets include for each target</p>
<ul class="simple">
<li><p>source_i : tuple - source variable i</p></li>
<li><p>selected_vars_sources : list of tuples - source variables used in PID
estimation</p></li>
<li><p>avg : dict - avg pid {alpha -&gt; float} where alpha is a redundancy
lattice node</p></li>
<li><p>ptw : dict of dicts - ptw pid {rlz -&gt; {alpha -&gt; float} } where rlz is
a single realisation of the random variables and alpha is a redundancy
lattice node</p></li>
<li><p>current_value : tuple - current value used for analysis, described by
target and sample index in the data</p></li>
<li><p>[estimator-specific settings]</p></li>
</ul>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>target<span class="classifier">int</span></dt><dd><p>target id</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>dict</dt><dd><p>Results for single target. Note that for convenience
dictionary entries can either be accessed via keywords
(result[‘selected_vars_sources’]) or via dot-notation
(result.selected_vars_sources).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="idtxl.results.ResultsNetworkAnalysis">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.results.</span></code><code class="sig-name descname"><span class="pre">ResultsNetworkAnalysis</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_nodes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_realisations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalised</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#ResultsNetworkAnalysis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.ResultsNetworkAnalysis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.results.Results" title="idtxl.results.Results"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.results.Results</span></code></a></p>
<dl class="py method">
<dt id="idtxl.results.ResultsNetworkAnalysis.get_single_target">
<code class="sig-name descname"><span class="pre">get_single_target</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fdr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#ResultsNetworkAnalysis.get_single_target"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.ResultsNetworkAnalysis.get_single_target" title="Permalink to this definition">¶</a></dt>
<dd><p>Return results for a single target in the network.</p>
<p>Return results for individual processes, contains for each process</p>
<p>Results for single targets include for each target</p>
<ul class="simple">
<li><p>omnibus_te : float - TE-value for joint information transfer from all
sources into the target</p></li>
<li><p>omnibus_pval : float - p-value of omnibus information transfer into
the target</p></li>
<li><p>omnibus_sign : bool - significance of omnibus information transfer
wrt. to the alpha_omnibus specified in the settings</p></li>
<li><p>selected_vars_sources : list of tuples - source variables with
significant information about the current value</p></li>
<li><p>selected_vars_target : list of tuples - target variables with
significant information about the current value</p></li>
<li><p>selected_sources_pval : array of floats - p-value for each selected
variable</p></li>
<li><p>selected_sources_te : array of floats - TE-value for each selected
variable</p></li>
<li><p>sources_tested : list of int - list of sources tested for the current
target</p></li>
<li><p>current_value : tuple - current value used for analysis, described by
target and sample index in the data</p></li>
</ul>
<p>Setting fdr to True returns FDR-corrected results (Benjamini, 1995).</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>target<span class="classifier">int</span></dt><dd><p>target id</p>
</dd>
<dt>fdr<span class="classifier">bool [optional]</span></dt><dd><p>return FDR-corrected results, see documentation of network
inference algorithms and stats.network_fdr (default=True)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>dict</dt><dd><p>Results for single target. Note that for convenience
dictionary entries can either be accessed via keywords
(result[‘selected_vars_sources’]) or via dot-notation
(result.selected_vars_sources).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.results.ResultsNetworkAnalysis.get_target_sources">
<code class="sig-name descname"><span class="pre">get_target_sources</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fdr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#ResultsNetworkAnalysis.get_target_sources"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.ResultsNetworkAnalysis.get_target_sources" title="Permalink to this definition">¶</a></dt>
<dd><p>Return list of sources (parents) for given target.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>target<span class="classifier">int</span></dt><dd><p>target index</p>
</dd>
<dt>fdr<span class="classifier">bool [optional]</span></dt><dd><p>if True, sources are returned for FDR-corrected results
(default=True)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.results.ResultsNetworkAnalysis.targets_analysed">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">targets_analysed</span></code><a class="headerlink" href="#idtxl.results.ResultsNetworkAnalysis.targets_analysed" title="Permalink to this definition">¶</a></dt>
<dd><p>Get index of the current_value.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="idtxl.results.ResultsNetworkComparison">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.results.</span></code><code class="sig-name descname"><span class="pre">ResultsNetworkComparison</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_nodes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_realisations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalised</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#ResultsNetworkComparison"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.ResultsNetworkComparison" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.results.ResultsNetworkAnalysis" title="idtxl.results.ResultsNetworkAnalysis"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.results.ResultsNetworkAnalysis</span></code></a></p>
<p>Store results of network comparison.</p>
<p>Provide a container for results of network comparison algorithms.</p>
<p>Note that for convenience all dictionaries in this class can additionally
be accessed using dot-notation: res_network.settings.cmi_estimator
or res_network.settings[‘cmi_estimator’].</p>
<dl>
<dt>Attributes:</dt><dd><dl>
<dt>settings<span class="classifier">dict</span></dt><dd><p>settings used for estimation of information theoretic measures and
statistical testing</p>
</dd>
<dt>data_properties<span class="classifier">dict</span></dt><dd><p>data properties, contains</p>
<blockquote>
<div><ul class="simple">
<li><p>n_nodes : int - total number of nodes in the network</p></li>
<li><p>n_realisations : int - number of samples available for
analysis given the settings (e.g., a high maximum lag used in
network inference, results in fewer data points available for
estimation)</p></li>
<li><p>normalised : bool - indicates if data were z-standardised
before the estimation</p></li>
</ul>
</div></blockquote>
</dd>
<dt>surrogate_distribution<span class="classifier">dict</span></dt><dd><p>for each target, surrogate distributions used for testing of each
link into the target</p>
</dd>
<dt>targets_analysed<span class="classifier">list</span></dt><dd><p>list of analysed targets</p>
</dd>
<dt>ab<span class="classifier">dict</span></dt><dd><p>for each target, list of comparison results for all links into the
target; True if link in condition A &gt; link in condition B</p>
</dd>
<dt>pval<span class="classifier">dict</span></dt><dd><p>for each target, list of p-values for all compared links</p>
</dd>
<dt>cmi_diff_abs<span class="classifier">dict</span></dt><dd><p>for each target, list of absolute difference in interaction measure
for all compared links</p>
</dd>
<dt>data_properties<span class="classifier">dict</span></dt><dd><p>information regarding the data used for analysis</p>
</dd>
<dt>settings<span class="classifier">dict</span></dt><dd><p>settings used for comparison</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="idtxl.results.ResultsNetworkComparison.get_adjacency_matrix">
<code class="sig-name descname"><span class="pre">get_adjacency_matrix</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'comparison'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#ResultsNetworkComparison.get_adjacency_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.ResultsNetworkComparison.get_adjacency_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return adjacency matrix.</p>
<p>Return adjacency matrix resulting from network inference.
Multiple options for the weights are available.</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>weights<span class="classifier">str [optional]</span></dt><dd><p>can either be</p>
<ul class="simple">
<li><p>‘union’: all links in the union network, i.e., all
links that were tested for a difference</p></li>
</ul>
<p>or return information for links with a significant difference</p>
<ul class="simple">
<li><dl class="simple">
<dt>‘comparison’: True for links with a significant difference in</dt><dd><p>inferred effective connectivity (default)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘pvalue’: absolute differences in inferred effective</dt><dd><p>connectivity for significant links</p>
</dd>
</dl>
</li>
<li><p>‘diff_abs’: absolute difference</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>AdjacencyMatrix instance</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.results.ResultsNetworkComparison.get_single_target">
<code class="sig-name descname"><span class="pre">get_single_target</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#ResultsNetworkComparison.get_single_target"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.ResultsNetworkComparison.get_single_target" title="Permalink to this definition">¶</a></dt>
<dd><p>Return results for a single target in the network.</p>
<p>Results for single targets include for each target</p>
<ul class="simple">
<li><p>sources : list of ints - list of sources inferred for the current
target (union of sources from both data sets entering the comparison)</p></li>
<li><p>selected_vars_sources : list of tuples - source variables with
significant information about the current value (union of both
conditions)</p></li>
<li><p>selected_vars_target : list of tuples - target variables with
significant information about the current value (union of both
conditions)</p></li>
</ul>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>target<span class="classifier">int</span></dt><dd><p>target id</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>dict</dt><dd><p>Results for single target. Note that for convenience
dictionary entries can either be accessed via keywords
(result[‘selected_vars_sources’]) or via dot-notation
(result.selected_vars_sources).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.results.ResultsNetworkComparison.get_target_sources">
<code class="sig-name descname"><span class="pre">get_target_sources</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#ResultsNetworkComparison.get_target_sources"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.ResultsNetworkComparison.get_target_sources" title="Permalink to this definition">¶</a></dt>
<dd><p>Return list of sources (parents) for given target.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>target<span class="classifier">int</span></dt><dd><p>target index</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.results.ResultsNetworkComparison.print_edge_list">
<code class="sig-name descname"><span class="pre">print_edge_list</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'comparison'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#ResultsNetworkComparison.print_edge_list"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.ResultsNetworkComparison.print_edge_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Print results of network comparison to console.</p>
<p>Print results of network comparison to console. Output looks like this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">0</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">diff_abs</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">0</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">diff_abs</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">0</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="p">,</span> <span class="n">diff_abs</span> <span class="o">=</span> <span class="mf">0.7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">3</span> <span class="o">-&gt;</span> <span class="mi">4</span><span class="p">,</span> <span class="n">diff_abs</span> <span class="o">=</span> <span class="mf">1.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">4</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="p">,</span> <span class="n">diff_abs</span> <span class="o">=</span> <span class="mf">0.4</span>
</pre></div>
</div>
<p>indicating differences in the network inference measure for a link
source -&gt; target.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>weights<span class="classifier">str [optional]</span></dt><dd><p>weights for the adjacency matrix (see documentation of method
get_adjacency_matrix for details)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="idtxl.results.ResultsNetworkInference">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.results.</span></code><code class="sig-name descname"><span class="pre">ResultsNetworkInference</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_nodes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_realisations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalised</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#ResultsNetworkInference"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.ResultsNetworkInference" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.results.ResultsNetworkAnalysis" title="idtxl.results.ResultsNetworkAnalysis"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.results.ResultsNetworkAnalysis</span></code></a></p>
<p>Store results of network inference.</p>
<p>Provide a container for results of network inference algorithms, e.g.,
MultivariateTE or Bivariate TE.</p>
<p>Note that for convenience all dictionaries in this class can additionally
be accessed using dot-notation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res_network</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">cmi_estimator</span>
</pre></div>
</div>
<p>or</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res_network</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;cmi_estimator&#39;</span><span class="p">]</span><span class="o">.</span>
</pre></div>
</div>
<dl>
<dt>Attributes:</dt><dd><dl>
<dt>settings<span class="classifier">dict</span></dt><dd><p>settings used for estimation of information theoretic measures and
statistical testing</p>
</dd>
<dt>data_properties<span class="classifier">dict</span></dt><dd><p>data properties, contains</p>
<blockquote>
<div><ul class="simple">
<li><p>n_nodes : int - total number of nodes in the network</p></li>
<li><p>n_realisations : int - number of samples available for
analysis given the settings (e.g., a high maximum lag used in
network inference, results in fewer data points available for
estimation)</p></li>
<li><p>normalised : bool - indicates if data were z-standardised
before estimation</p></li>
</ul>
</div></blockquote>
</dd>
<dt>targets_analysed<span class="classifier">list</span></dt><dd><p>list of analysed targets</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="idtxl.results.ResultsNetworkInference.get_adjacency_matrix">
<code class="sig-name descname"><span class="pre">get_adjacency_matrix</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fdr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#ResultsNetworkInference.get_adjacency_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.ResultsNetworkInference.get_adjacency_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return adjacency matrix.</p>
<p>Return adjacency matrix resulting from network inference. The adjacency
matrix can either be generated from FDR-corrected results or
uncorrected results. Multiple options for the weight are available.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>weights<span class="classifier">str</span></dt><dd><p>can either be</p>
<ul class="simple">
<li><dl class="simple">
<dt>‘max_te_lag’: the weights represent the source -&gt; target</dt><dd><p>lag corresponding to the maximum tranfer entropy value
(see documentation for method get_target_delays for details)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘max_p_lag’: the weights represent the source -&gt; target</dt><dd><p>lag corresponding to the maximum p-value
(see documentation for method get_target_delays for details)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘vars_count’: the weights represent the number of</dt><dd><p>statistically-significant source -&gt; target lags</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘binary’: return unweighted adjacency matrix with binary</dt><dd><p>entries</p>
<ul>
<li><p>1 = significant information transfer;</p></li>
<li><p>0 = no significant information transfer.</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt>fdr<span class="classifier">bool [optional]</span></dt><dd><p>return FDR-corrected results (default=True)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>AdjacencyMatrix instance</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.results.ResultsNetworkInference.get_target_delays">
<code class="sig-name descname"><span class="pre">get_target_delays</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">criterion</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'max_te'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fdr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#ResultsNetworkInference.get_target_delays"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.ResultsNetworkInference.get_target_delays" title="Permalink to this definition">¶</a></dt>
<dd><p>Return list of information-transfer delays for a given target.</p>
<p>Return a list of information-transfer delays for a given target.
Information-transfer delays are determined by the lag of the variable
in a source past that has the highest information transfer into the
target process. There are two ways of identifying the variable with
maximum information transfer:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><p>use the variable with the highest absolute TE value (highest
information transfer),</p></li>
<li><p>use the variable with the smallest p-value (highest statistical
significance).</p></li>
</ol>
</div></blockquote>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>target<span class="classifier">int</span></dt><dd><p>target index</p>
</dd>
<dt>criterion<span class="classifier">str [optional]</span></dt><dd><p>use maximum TE value (‘max_te’) or p-value (‘max_p’) to
determine the source-target delay (default=’max_te’)</p>
</dd>
<dt>fdr<span class="classifier">bool [optional]</span></dt><dd><p>return FDR-corrected results (default=True)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>numpy array</dt><dd><p>information-transfer delays for each source</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.results.ResultsNetworkInference.print_edge_list">
<code class="sig-name descname"><span class="pre">print_edge_list</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fdr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#ResultsNetworkInference.print_edge_list"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.ResultsNetworkInference.print_edge_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Print results of network inference to console.</p>
<p>Print edge list resulting from network inference to console.
Output may look like this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">0</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">max_te_lag</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">0</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">max_te_lag</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">0</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="p">,</span> <span class="n">max_te_lag</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">3</span> <span class="o">-&gt;</span> <span class="mi">4</span><span class="p">,</span> <span class="n">max_te_lag</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">4</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="p">,</span> <span class="n">max_te_lag</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>The edge list can either be generated from FDR-corrected results
or uncorrected results. Multiple options for the weight
are available (see documentation of method get_adjacency_matrix for
details).</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>weights<span class="classifier">str</span></dt><dd><p>link weights (see documentation of method get_adjacency_matrix
for details)</p>
</dd>
<dt>fdr<span class="classifier">bool [optional]</span></dt><dd><p>return FDR-corrected results (default=True)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="idtxl.results.ResultsPID">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.results.</span></code><code class="sig-name descname"><span class="pre">ResultsPID</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_nodes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_realisations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalised</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#ResultsPID"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.ResultsPID" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.results.ResultsNetworkAnalysis" title="idtxl.results.ResultsNetworkAnalysis"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.results.ResultsNetworkAnalysis</span></code></a></p>
<p>Store results of Partial Information Decomposition (PID) analysis.</p>
<p>Provide a container for results of Partial Information Decomposition (PID)
algorithms.</p>
<p>Note that for convenience all dictionaries in this class can additionally
be accessed using dot-notation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res_pid</span><span class="o">.</span><span class="n">_single_target</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">source_1</span>
</pre></div>
</div>
<p>or</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res_pid</span><span class="o">.</span><span class="n">_single_target</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="p">[</span><span class="s1">&#39;source_1&#39;</span><span class="p">]</span><span class="o">.</span>
</pre></div>
</div>
<dl>
<dt>Attributes:</dt><dd><dl>
<dt>settings<span class="classifier">dict</span></dt><dd><p>settings used for estimation of information theoretic measures and
statistical testing</p>
</dd>
<dt>data_properties<span class="classifier">dict</span></dt><dd><p>data properties, contains</p>
<blockquote>
<div><ul class="simple">
<li><p>n_nodes : int - total number of nodes in the network</p></li>
<li><p>n_realisations : int - number of samples available for
analysis given the settings (e.g., a high maximum lag used in
network inference, results in fewer data points available for
estimation)</p></li>
<li><p>normalised : bool - indicates if data were z-standardised
before the estimation</p></li>
</ul>
</div></blockquote>
</dd>
<dt>targets_analysed<span class="classifier">list</span></dt><dd><p>list of analysed targets</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="idtxl.results.ResultsPID.get_single_target">
<code class="sig-name descname"><span class="pre">get_single_target</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#ResultsPID.get_single_target"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.ResultsPID.get_single_target" title="Permalink to this definition">¶</a></dt>
<dd><p>Return results for a single target in the network.</p>
<p>Results for single targets include for each target</p>
<ul class="simple">
<li><p>source_1 : tuple - source variable 1</p></li>
<li><p>source_2 : tuple - source variable 2</p></li>
<li><p>selected_vars_sources : list of tuples - source variables used in PID
estimation</p></li>
<li><p>s1_unq : float - unique information in source 1</p></li>
<li><p>s2_unq : float - unique information in source 2</p></li>
<li><p>syn_s1_s2 : float - synergistic information in sources 1 and 2</p></li>
<li><p>shd_s1_s2 : float - shared information in sources 1 and 2</p></li>
<li><p>current_value : tuple - current value used for analysis, described by
target and sample index in the data</p></li>
<li><p>[estimator-specific settings]</p></li>
</ul>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>target<span class="classifier">int</span></dt><dd><p>target id</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>dict</dt><dd><p>Results for single target. Note that for convenience
dictionary entries can either be accessed via keywords
(result[‘selected_vars_sources’]) or via dot-notation
(result.selected_vars_sources).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="idtxl.results.ResultsSingleProcessAnalysis">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">idtxl.results.</span></code><code class="sig-name descname"><span class="pre">ResultsSingleProcessAnalysis</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_nodes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_realisations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalised</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#ResultsSingleProcessAnalysis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.ResultsSingleProcessAnalysis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.results.Results" title="idtxl.results.Results"><code class="xref py py-class docutils literal notranslate"><span class="pre">idtxl.results.Results</span></code></a></p>
<p>Store results of single process analysis.</p>
<p>Provide a container for the results of algorithms for the analysis of
individual processes (nodes) in a multivariate stochastic process,
e.g., estimation of active information storage.</p>
<p>Note that for convenience all dictionaries in this class can additionally
be accessed using dot-notation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res_network</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">cmi_estimator</span>
</pre></div>
</div>
<p>or</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res_network</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;cmi_estimator&#39;</span><span class="p">]</span><span class="o">.</span>
</pre></div>
</div>
<dl>
<dt>Attributes:</dt><dd><dl>
<dt>settings<span class="classifier">dict</span></dt><dd><p>settings used for estimation of information theoretic measures and
statistical testing</p>
</dd>
<dt>data_properties<span class="classifier">dict</span></dt><dd><p>data properties, contains</p>
<blockquote>
<div><ul class="simple">
<li><p>n_nodes : int - total number of nodes in the network</p></li>
<li><p>n_realisations : int - number of samples available for
analysis given the settings (e.g., a high maximum lag used in
network inference, results in fewer data points available for
estimation)</p></li>
<li><p>normalised : bool - indicates if data were z-standardised
before estimation</p></li>
</ul>
</div></blockquote>
</dd>
<dt>processes_analysed<span class="classifier">list</span></dt><dd><p>list of analysed processes</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="idtxl.results.ResultsSingleProcessAnalysis.get_significant_processes">
<code class="sig-name descname"><span class="pre">get_significant_processes</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fdr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#ResultsSingleProcessAnalysis.get_significant_processes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.ResultsSingleProcessAnalysis.get_significant_processes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return statistically-significant processes.</p>
<p>Indicates for each process whether AIS is statistically significant
(equivalent to the adjacency matrix returned for network inference)</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>fdr<span class="classifier">bool [optional]</span></dt><dd><p>return FDR-corrected results, see documentation of network
inference algorithms and stats.network_fdr (default=True)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>numpy array</dt><dd><p>Statistical significance for each process</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.results.ResultsSingleProcessAnalysis.get_single_process">
<code class="sig-name descname"><span class="pre">get_single_process</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">process</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fdr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/results.html#ResultsSingleProcessAnalysis.get_single_process"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.results.ResultsSingleProcessAnalysis.get_single_process" title="Permalink to this definition">¶</a></dt>
<dd><p>Return results for a single process in the network.</p>
<p>Return results for individual processes, contains for each process</p>
<blockquote>
<div><ul class="simple">
<li><p>ais : float - AIS-value for current process</p></li>
<li><p>ais_pval : float - p-value of AIS estimate</p></li>
<li><dl class="simple">
<dt>ais_sign<span class="classifier">bool - significance of AIS estimate wrt. to the</span></dt><dd><p>alpha_mi specified in the settings</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>selected_var<span class="classifier">list of tuples - variables with significant</span></dt><dd><p>information about the current value of the process that have
been added to the processes past state, a variable is
described by the index of the process in the data and its lag
in samples</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>current_value<span class="classifier">tuple - current value used for analysis,</span></dt><dd><p>described by target and sample index in the data</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>Setting fdr to True returns FDR-corrected results (Benjamini, 1995).</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>process<span class="classifier">int</span></dt><dd><p>process id</p>
</dd>
<dt>fdr<span class="classifier">bool [optional]</span></dt><dd><p>return FDR-corrected results, see documentation of network
inference algorithms and stats.network_fdr (default=True)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>dict</dt><dd><p>results for single process. Note that for convenience
dictionary entries can either be accessed via keywords
(result[‘selected_vars’]) or via dot-notation
(result.selected_vars).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="idtxl.results.ResultsSingleProcessAnalysis.processes_analysed">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">processes_analysed</span></code><a class="headerlink" href="#idtxl.results.ResultsSingleProcessAnalysis.processes_analysed" title="Permalink to this definition">¶</a></dt>
<dd><p>Get index of the current_value.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-idtxl.stats">
<span id="idtxl-stats-module"></span><h2>idtxl.stats module<a class="headerlink" href="#module-idtxl.stats" title="Permalink to this headline">¶</a></h2>
<p>Provide statistics functions.</p>
<dl class="py function">
<dt id="idtxl.stats.ais_fdr">
<code class="sig-prename descclassname"><span class="pre">idtxl.stats.</span></code><code class="sig-name descname"><span class="pre">ais_fdr</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">results</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/stats.html#ais_fdr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.stats.ais_fdr" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform FDR-correction on results of network AIS estimation.</p>
<p>Perform correction of the false discovery rate (FDR) after estimation of
active information storage (AIS) for all processes in the network. FDR
correction is applied by correcting the AIS estimate’s omnibus p-values for
individual processes/nodes in the network.</p>
<p>Input can be a list of partial results to combine results from parallel
analysis.</p>
<p>References:</p>
<ul class="simple">
<li><p>Genovese, C.R., Lazar, N.A., &amp; Nichols, T. (2002). Thresholding of
statistical maps in functional neuroimaging using the false discovery
rate. Neuroimage, 15(4), 870-878.</p></li>
</ul>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>parameters for statistical testing with entries:</p>
<ul class="simple">
<li><p>alpha_fdr : float [optional] - critical alpha level
(default=0.05)</p></li>
<li><p>fdr_constant : int [optional] - choose one of two constants used
for calculating the FDR-thresholds according to Genovese (2002):
1 will divide alpha by 1, 2 will divide alpha by the sum_i(1/i);
see the paper for details on the assumptions (default=2)</p></li>
</ul>
</dd>
<dt>results<span class="classifier">instances of ResultsSingleProcessAnalysis</span></dt><dd><p>results of network AIS estimation, see documentation of
ResultsSingleProcessAnalysis()</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>ResultsSingleProcessAnalysis instance</dt><dd><p>input results objects pruned of non-significant estimates</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="idtxl.stats.check_n_perm">
<code class="sig-prename descclassname"><span class="pre">idtxl.stats.</span></code><code class="sig-name descname"><span class="pre">check_n_perm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_perm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/stats.html#check_n_perm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.stats.check_n_perm" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if no. permutations is big enough to obtain the requested alpha.</p>
<dl class="simple">
<dt>Note:</dt><dd><p>The no. permutations must be big enough to theoretically allow for the
detection of a p-value that is smaller than the critical alpha level.
Otherwise the permutation test is pointless. The smalles possible
p-value is 1/n_perm.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="idtxl.stats.max_statistic">
<code class="sig-prename descclassname"><span class="pre">idtxl.stats.</span></code><code class="sig-name descname"><span class="pre">max_statistic</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">analysis_setup</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">candidate_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">te_max_candidate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conditional</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/stats.html#max_statistic"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.stats.max_statistic" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform maximum statistics for one candidate source.</p>
<p>Test if a transfer entropy value is significantly bigger than the maximum
values obtained from surrogates of all remanining candidates.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>analysis_setup<span class="classifier">MultivariateTE instance</span></dt><dd><p>information on the current analysis, can have an optional attribute
‘settings’, a dictionary with parameters for statistical testing:</p>
<ul class="simple">
<li><p>n_perm_max_stat : int [optional] - number of permutations
(default=200)</p></li>
<li><p>alpha_max_stat : float [optional] - critical alpha level
(default=0.05)</p></li>
<li><p>permute_in_time : bool [optional] - generate surrogates by
shuffling samples in time instead of shuffling whole replications
(default=False)</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data</p>
</dd>
<dt>candidate_set<span class="classifier">list of tuples</span></dt><dd><p>list of indices of remaning candidates</p>
</dd>
<dt>te_max_candidate<span class="classifier">float</span></dt><dd><p>transfer entropy value to be tested</p>
</dd>
<dt>conditional<span class="classifier">numpy array [optional]</span></dt><dd><p>realisations of conditional, 2D numpy array where array dimensions
represent [realisations x variable dimension] (default=None, no
conditioning performed)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>bool</dt><dd><p>statistical significance</p>
</dd>
<dt>float</dt><dd><p>the test’s p-value</p>
</dd>
<dt>numpy array</dt><dd><p>surrogate table</p>
</dd>
</dl>
</dd>
<dt>Raises:</dt><dd><dl class="simple">
<dt>ex.AlgorithmExhaustedError</dt><dd><p>Raised from _create_surrogate_table() when calculation cannot be
made</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="idtxl.stats.max_statistic_sequential">
<code class="sig-prename descclassname"><span class="pre">idtxl.stats.</span></code><code class="sig-name descname"><span class="pre">max_statistic_sequential</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">analysis_setup</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/stats.html#max_statistic_sequential"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.stats.max_statistic_sequential" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform sequential maximum statistics for a set of candidate sources.</p>
<p>Test multivariate/bivariate MI/TE values against surrogates. Test highest
TE/MI value against distribution of highest surrogate values, second
highest against distribution of second highest, and so forth. Surrogates
are created from each candidate in the candidate set, including the
candidate that is currently tested. Surrogates are then sorted over
candidates. This is repeated n_perm_max_seq times. Stop comparison if a
TE/MI value is not significant compared to the distribution of surrogate
values of the same rank. All smaller values are considered non-significant
as well.</p>
<p>The conditional for estimation of MI/TE is taken from the current set of
conditional variables in the analysis setup. For multivariate MI or TE
surrogate creation, the full set of conditional variables is used. For
bivariate MI or TE surrogate creation, the conditioning set has to be
restricted to a subset of the current set of conditional variables: for
bivariate MI no conditioning set is required, for bivariate TE only the
past variables from the target are required (not the variables selected
from other relevant sources).</p>
<p>This function will re-use the surrogate table created in the last min-stats
round if that table is in the analysis_setup. This saves the complete
calculation of surrogates for this statistic.</p>
<p>Args:</p>
<blockquote>
<div><dl class="simple">
<dt>analysis_setup<span class="classifier">MultivariateTE instance</span></dt><dd><p>information on the current analysis, can have an optional attribute
‘settings’, a dictionary with parameters for statistical testing:</p>
<ul class="simple">
<li><p>n_perm_max_seq : int [optional] - number of permutations
(default=’n_perm_min_stat’<a href="#id3"><span class="problematic" id="id4">|</span></a>500)</p></li>
<li><p>alpha_max_seq : float [optional] - critical alpha level
(default=0.05)</p></li>
<li><p>permute_in_time : bool [optional] - generate surrogates by
shuffling samples in time instead of shuffling whole replications
(default=False)</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt>numpy array, bool</dt><dd><p>statistical significance of each source</p>
</dd>
<dt>numpy array, float</dt><dd><p>the test’s p-values for each source</p>
</dd>
<dt>numpy array, float</dt><dd><p>TE values for individual sources</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="idtxl.stats.max_statistic_sequential_bivariate">
<code class="sig-prename descclassname"><span class="pre">idtxl.stats.</span></code><code class="sig-name descname"><span class="pre">max_statistic_sequential_bivariate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">analysis_setup</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/stats.html#max_statistic_sequential_bivariate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.stats.max_statistic_sequential_bivariate" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform sequential maximum statistics for a set of candidate sources.</p>
<p>Test multivariate/bivariate MI/TE values against surrogates. Test highest
TE/MI value against distribution of highest surrogate values, second
highest against distribution of second highest, and so forth. Surrogates
are created from each candidate in the candidate set, including the
candidate that is currently tested. Surrogates are then sorted over
candidates. This is repeated n_perm_max_seq times. Stop comparison if a
TE/MI value is not significant compared to the distribution of surrogate
values of the same rank. All smaller values are considered non-significant
as well.</p>
<p>The conditional for estimation of MI/TE is taken from the current set of
conditional variables in the analysis setup. For multivariate MI or TE
surrogate creation, the full set of conditional variables is used. For
bivariate MI or TE surrogate creation, the conditioning set has to be
restricted to a subset of the current set of conditional variables: for
bivariate MI no conditioning set is required, for bivariate TE only the
past variables from the target are required (not the variables selected
from other relevant sources).</p>
<p>This function will re-use the surrogate table created in the last min-stats
round if that table is in the analysis_setup. This saves the complete
calculation of surrogates for this statistic.</p>
<p>Args:</p>
<blockquote>
<div><dl class="simple">
<dt>analysis_setup<span class="classifier">MultivariateTE instance</span></dt><dd><p>information on the current analysis, can have an optional attribute
‘settings’, a dictionary with parameters for statistical testing:</p>
<ul class="simple">
<li><p>n_perm_max_seq : int [optional] - number of permutations
(default=’n_perm_min_stat’<a href="#id5"><span class="problematic" id="id6">|</span></a>500)</p></li>
<li><p>alpha_max_seq : float [optional] - critical alpha level
(default=0.05)</p></li>
<li><p>permute_in_time : bool [optional] - generate surrogates by
shuffling samples in time instead of shuffling whole replications
(default=False)</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt>numpy array, bool</dt><dd><p>statistical significance of each source</p>
</dd>
<dt>numpy array, float</dt><dd><p>the test’s p-values for each source</p>
</dd>
<dt>numpy array, float</dt><dd><p>TE values for individual sources</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="idtxl.stats.mi_against_surrogates">
<code class="sig-prename descclassname"><span class="pre">idtxl.stats.</span></code><code class="sig-name descname"><span class="pre">mi_against_surrogates</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">analysis_setup</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/stats.html#mi_against_surrogates"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.stats.mi_against_surrogates" title="Permalink to this definition">¶</a></dt>
<dd><p>Test estimated mutual information for significance against surrogate data.</p>
<p>Shuffle realisations of the current value (point to be predicted) and re-
calculate mutual information (MI) for shuffled data. The actual estimated
MI is then compared against this distribution of MI values from surrogate
data.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>analysis_setup<span class="classifier">MultivariateTE instance</span></dt><dd><p>information on the current analysis, can have an optional attribute
‘settings’, a dictionary with parameters for statistical testing:</p>
<ul class="simple">
<li><p>n_perm_mi : int [optional] - number of permutations
(default=500)</p></li>
<li><p>alpha_mi : float [optional] - critical alpha level
(default=0.05)</p></li>
<li><p>permute_in_time : bool [optional] - generate surrogates by
shuffling samples in time instead of shuffling whole replications
(default=False)</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>float</dt><dd><p>estimated MI value</p>
</dd>
<dt>bool</dt><dd><p>statistical significance</p>
</dd>
<dt>float</dt><dd><p>p_value for estimated MI value</p>
</dd>
</dl>
</dd>
<dt>Raises:</dt><dd><dl class="simple">
<dt>ex.AlgorithmExhaustedError</dt><dd><p>Raised from estimate() methods when calculation cannot be made</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="idtxl.stats.min_statistic">
<code class="sig-prename descclassname"><span class="pre">idtxl.stats.</span></code><code class="sig-name descname"><span class="pre">min_statistic</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">analysis_setup</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">candidate_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">te_min_candidate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conditional</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/stats.html#min_statistic"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.stats.min_statistic" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform minimum statistics for one candidate source.</p>
<p>Test if a transfer entropy value is significantly bigger than the minimum
values obtained from surrogates of all remanining candidates.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>analysis_setup<span class="classifier">MultivariateTE instance</span></dt><dd><p>information on the current analysis, can have an optional attribute
‘settings’, a dictionary with parameters for statistical testing:</p>
<ul class="simple">
<li><p>n_perm_min_stat : int [optional] - number of permutations
(default=500)</p></li>
<li><p>alpha_min_stat : float [optional] - critical alpha level
(default=0.05)</p></li>
<li><p>permute_in_time : bool [optional] - generate surrogates by
shuffling samples in time instead of shuffling whole replications
(default=False)</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data</p>
</dd>
<dt>candidate_set<span class="classifier">list of tuples</span></dt><dd><p>list of indices of remaning candidates</p>
</dd>
<dt>te_min_candidate<span class="classifier">float</span></dt><dd><p>transfer entropy value to be tested</p>
</dd>
<dt>conditional<span class="classifier">numpy array [optional]</span></dt><dd><p>realisations of conditional, 2D numpy array where array dimensions
represent [realisations x variable dimension] (default=None, no
conditioning performed)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>bool</dt><dd><p>statistical significance</p>
</dd>
<dt>float</dt><dd><p>the test’s p-value</p>
</dd>
<dt>numpy array</dt><dd><p>surrogate table</p>
</dd>
</dl>
</dd>
<dt>Raises:</dt><dd><dl class="simple">
<dt>ex.AlgorithmExhaustedError</dt><dd><p>Raised from _create_surrogate_table() when calculation cannot be
made</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="idtxl.stats.network_fdr">
<code class="sig-prename descclassname"><span class="pre">idtxl.stats.</span></code><code class="sig-name descname"><span class="pre">network_fdr</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">results</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/stats.html#network_fdr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.stats.network_fdr" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform FDR-correction on results of network inference.</p>
<p>Perform correction of the false discovery rate (FDR) after network
analysis. FDR correction can either be applied at the target level
(by correcting omnibus p-values) or at the single-link level (by correcting
p-values of individual links between single samples and the target).</p>
<p>Input can be a list of partial results to combine results from parallel
analysis.</p>
<p>References:</p>
<ul class="simple">
<li><p>Genovese, C.R., Lazar, N.A., &amp; Nichols, T. (2002). Thresholding of
statistical maps in functional neuroimaging using the false discovery
rate. Neuroimage, 15(4), 870-878.</p></li>
</ul>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>settings<span class="classifier">dict [optional]</span></dt><dd><p>parameters for statistical testing with entries:</p>
<ul class="simple">
<li><p>alpha_fdr : float [optional] - critical alpha level
(default=0.05)</p></li>
<li><p>correct_by_target : bool [optional] - if true correct p-values on
on the target level (omnibus test p-values), otherwise correct
p_values for individual variables (sequential max stats p-values)
(default=True)</p></li>
<li><p>fdr_constant : int [optional] - choose one of two constants used
for calculating the FDR-thresholds according to Genovese (2002):
1 will divide alpha by 1, 2 will divide alpha by the sum_i(1/i);
see the paper for details on the assumptions (default=2)</p></li>
</ul>
</dd>
<dt>results<span class="classifier">instances of ResultsNetworkInference</span></dt><dd><p>results of network inference, see documentation of
ResultsNetworkInference()</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>ResultsNetworkInference instance</dt><dd><p>input object pruned of non-significant links</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="idtxl.stats.omnibus_test">
<code class="sig-prename descclassname"><span class="pre">idtxl.stats.</span></code><code class="sig-name descname"><span class="pre">omnibus_test</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">analysis_setup</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/stats.html#omnibus_test"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.stats.omnibus_test" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform an omnibus test on identified conditional variables.</p>
<p>Test the joint information transfer from all identified sources to the
current value conditional on candidates in the target’s past. To test for
significance, this is repeated for shuffled realisations of the sources.
The distribution of values from shuffled data is then used as test
distribution.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>analysis_setup<span class="classifier">MultivariateTE instance</span></dt><dd><p>information on the current analysis, can have an optional attribute
‘settings’, a dictionary with parameters for statistical testing:</p>
<ul class="simple">
<li><p>n_perm_omnibus : int [optional] - number of permutations
(default=500)</p></li>
<li><p>alpha_omnibus : float [optional] - critical alpha level
(default=0.05)</p></li>
<li><p>permute_in_time : bool [optional] - generate surrogates by
shuffling samples in time instead of shuffling whole replications
(default=False)</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>bool</dt><dd><p>statistical significance</p>
</dd>
<dt>float</dt><dd><p>the test’s p-value</p>
</dd>
<dt>float</dt><dd><p>the estimated test statisic, i.e., the information transfer from
all sources into the target</p>
</dd>
</dl>
</dd>
<dt>Raises:</dt><dd><dl class="simple">
<dt>ex.AlgorithmExhaustedError</dt><dd><p>Raised from estimate() calls when calculation cannot be made</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="idtxl.stats.syn_shd_against_surrogates">
<code class="sig-prename descclassname"><span class="pre">idtxl.stats.</span></code><code class="sig-name descname"><span class="pre">syn_shd_against_surrogates</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">analysis_setup</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/stats.html#syn_shd_against_surrogates"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.stats.syn_shd_against_surrogates" title="Permalink to this definition">¶</a></dt>
<dd><p>Test the shared/synergistic information in the PID estimate.</p>
<p>Shuffle realisations of the target and re-calculate PID, in particular the
synergistic and shared information from shuffled data. The original
shared and synergistic information are then compared against the
distribution of values calculated from surrogate data.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>analysis_setup<span class="classifier">Partial_information_decomposition instance</span></dt><dd><p>information on the current analysis, should have an Attribute
‘settings’, a dict with optional fields</p>
<ul class="simple">
<li><p>n_perm : int [optional] - number of permutations (default=500)</p></li>
<li><p>alpha : float [optional] - critical alpha level (default=0.05)</p></li>
<li><p>permute_in_time : bool [optional] - generate surrogates by
shuffling samples in time instead of shuffling whole replications
(default=False)</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>dict</dt><dd><p>PID estimate from original data</p>
</dd>
<dt>bool</dt><dd><p>statistical significance of the shared information</p>
</dd>
<dt>float</dt><dd><p>p-value of the shared information</p>
</dd>
<dt>bool</dt><dd><p>statistical significance of the synergistic information</p>
</dd>
<dt>float</dt><dd><p>p-value of the synergistic information</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="idtxl.stats.unq_against_surrogates">
<code class="sig-prename descclassname"><span class="pre">idtxl.stats.</span></code><code class="sig-name descname"><span class="pre">unq_against_surrogates</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">analysis_setup</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/stats.html#unq_against_surrogates"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.stats.unq_against_surrogates" title="Permalink to this definition">¶</a></dt>
<dd><p>Test the unique information in the PID estimate against surrogate data.</p>
<p>Shuffle realisations of both sources individually and re-calculate PID,
in particular the unique information from shuffled data. The original
unique information is then compared against the distribution of values
calculated from surrogate data.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>analysis_setup<span class="classifier">Partial_information_decomposition instance</span></dt><dd><p>information on the current analysis, should have an Attribute
‘settings’, a dict with optional fields</p>
<ul class="simple">
<li><p>n_perm : int [optional] - number of permutations (default=500)</p></li>
<li><p>alpha : float [optional] - critical alpha level (default=0.05)</p></li>
<li><p>permute_in_time : bool [optional] - generate surrogates by
shuffling samples in time instead of shuffling whole replications
(default=False)</p></li>
</ul>
</dd>
<dt>data<span class="classifier">Data instance</span></dt><dd><p>raw data</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>dict</dt><dd><p>PID estimate from original data</p>
</dd>
<dt>bool</dt><dd><p>statistical significance of the unique information in source 1</p>
</dd>
<dt>float</dt><dd><p>p-value of the unique information in source 1</p>
</dd>
<dt>bool</dt><dd><p>statistical significance of the unique information in source 2</p>
</dd>
<dt>float</dt><dd><p>p-value of the unique information in source 2</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-idtxl.visualise_graph">
<span id="idtxl-visualise-graph-module"></span><h2>idtxl.visualise_graph module<a class="headerlink" href="#module-idtxl.visualise_graph" title="Permalink to this headline">¶</a></h2>
<p>Plot results of network inference.</p>
<dl class="py function">
<dt id="idtxl.visualise_graph.plot_mute_graph">
<code class="sig-prename descclassname"><span class="pre">idtxl.visualise_graph.</span></code><code class="sig-name descname"><span class="pre">plot_mute_graph</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/visualise_graph.html#plot_mute_graph"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.visualise_graph.plot_mute_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot MuTE example network.</p>
<p>Network of 5 AR-processes, which is used as an example the paper
on the MuTE toolbox (Montalto, PLOS ONE, 2014, eq. 14). The
network consists of five autoregressive (AR) processes with model
orders 2 and les and the following (non-linear) couplings:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">0</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">0</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">0</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">(</span><span class="n">non</span><span class="o">-</span><span class="n">linear</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">3</span> <span class="o">-&gt;</span> <span class="mi">4</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">4</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt>Figure handle</dt><dd><p>Figure object from the matplotlib package</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="idtxl.visualise_graph.plot_network">
<code class="sig-prename descclassname"><span class="pre">idtxl.visualise_graph.</span></code><code class="sig-name descname"><span class="pre">plot_network</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">results</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fdr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/visualise_graph.html#plot_network"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.visualise_graph.plot_network" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot network of multivariate TE between processes.</p>
<p>Plot graph of the network of (multivariate) interactions between processes
(e.g., multivariate TE). The function uses  the networkx class for directed
graphs (DiGraph) internally. Plots a network and adjacency matrix.</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>results<span class="classifier">ResultsNetworkInference() instance</span></dt><dd><p>output of an network inference algorithm</p>
</dd>
<dt>weights<span class="classifier">str</span></dt><dd><p>for single network inference, it can either be</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>‘max_te_lag’: the weights represent the source -&gt; target</dt><dd><p>lag corresponding to the maximum tranfer entropy value
(see documentation for method get_target_delays for details)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘max_p_lag’: the weights represent the source -&gt; target</dt><dd><p>lag corresponding to the maximum p-value
(see documentation for method get_target_delays for details)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘vars_count’: the weights represent the number of</dt><dd><p>statistically-significant source -&gt; target lags</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘binary’: return unweighted adjacency matrix with binary</dt><dd><p>entries</p>
<ul>
<li><p>1 = significant information transfer;</p></li>
<li><p>0 = no significant information transfer.</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>for network comparison, it can either be</p>
<blockquote>
<div><ul class="simple">
<li><p>‘union’: all links in the union network, i.e., all
links that were tested for a difference</p></li>
<li><dl class="simple">
<dt>‘comparison’: True for links with a significant difference in</dt><dd><p>inferred effective connectivity (default)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘pvalue’: absolute differences in inferred effective</dt><dd><p>connectivity for significant links</p>
</dd>
</dl>
</li>
<li><p>‘diff_abs’: absolute difference</p></li>
</ul>
</div></blockquote>
</dd>
<dt>fdr<span class="classifier">bool [optional]</span></dt><dd><p>print FDR-corrected results (default=True)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>DiGraph</dt><dd><p>instance of a directed graph class from the networkx package</p>
</dd>
<dt>Figure</dt><dd><p>figure handle, Figure object from the matplotlib package</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="idtxl.visualise_graph.plot_network_comparison">
<code class="sig-prename descclassname"><span class="pre">idtxl.visualise_graph.</span></code><code class="sig-name descname"><span class="pre">plot_network_comparison</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">results</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/visualise_graph.html#plot_network_comparison"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.visualise_graph.plot_network_comparison" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot results of network comparison.</p>
<p>Plot results of network comparison. Produces a figure with five subplots,
where the first plot shows the network graph of the union network, the
second plot shows the adjacency matrix of the union network, the third
plot shows the qualitative results of the comparison of each link, the
fourth plot shows the absolute differences in CMI per link, and the fifth
plot shows p-values for each link.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>results<span class="classifier">ResultsNetworkComparison() instance</span></dt><dd><p>network comparison results</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>DiGraph</dt><dd><p>instance of a directed graph class from the networkx package</p>
</dd>
<dt>Figure</dt><dd><p>figure handle, Figure object from the matplotlib package</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="idtxl.visualise_graph.plot_selected_vars">
<code class="sig-prename descclassname"><span class="pre">idtxl.visualise_graph.</span></code><code class="sig-name descname"><span class="pre">plot_selected_vars</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">results</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sign_sources</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">display_edge_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fdr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/visualise_graph.html#plot_selected_vars"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#idtxl.visualise_graph.plot_selected_vars" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot network of a target process and single variables.</p>
<p>Plot graph of the network of (multivariate) interactions between source
variables and the target. The function uses the networkx class for directed
graphs (DiGraph) internally. Plots a network and reduced adjacency matrix.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>results<span class="classifier">ResultsNetworkInference() instance</span></dt><dd><p>output of an network inference algorithm</p>
</dd>
<dt>target<span class="classifier">int</span></dt><dd><p>index of target process</p>
</dd>
<dt>sign_sources<span class="classifier">bool [optional]</span></dt><dd><p>plot sources with significant information contribution only
(default=True)</p>
</dd>
<dt>display_edge_labels<span class="classifier">bool [optional]</span></dt><dd><p>display TE value on edge lables (default=False)</p>
</dd>
<dt>fdr<span class="classifier">bool [optional]</span></dt><dd><p>print FDR-corrected results (default=True)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>DiGraph</dt><dd><p>instance of a directed graph class from the networkx package</p>
</dd>
<dt>Figure</dt><dd><p>figure handle, Figure object from the matplotlib package</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-idtxl">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-idtxl" title="Permalink to this headline">¶</a></h2>
<p>IDTxl: Information Dynamics Toolkit xl.</p>
<p>IDTxl is a comprehensive software package for efficient inference of networks
and their node dynamics from multivariate time series data using information
theory. IDTxl provides functionality to estimate the following measures:</p>
<ol class="arabic">
<li><p>For network inference:</p>
<blockquote>
<div><ul class="simple">
<li><p>multivariate transfer entropy (TE)/Granger causality (GC)</p></li>
<li><p>multivariate mutual information (MI)</p></li>
<li><p>bivariate TE/GC</p></li>
<li><p>bivariate MI</p></li>
</ul>
</div></blockquote>
</li>
</ol>
<ol class="arabic" start="3">
<li><p>For analysis of node dynamics:</p>
<blockquote>
<div><ul class="simple">
<li><p>active information storage (AIS)</p></li>
<li><p>partial information decomposition (PID)</p></li>
</ul>
</div></blockquote>
</li>
</ol>
<p>IDTxl implements estimators for discrete and continuous data with parallel
computing engines for both GPU and CPU platforms. Written for Python3.4.3+.</p>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">idtxl package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-idtxl.data">idtxl.data module</a></li>
<li><a class="reference internal" href="#module-idtxl.bivariate_te">idtxl.bivariate_te module</a></li>
<li><a class="reference internal" href="#module-idtxl.bivariate_mi">idtxl.bivariate_mi module</a></li>
<li><a class="reference internal" href="#module-idtxl.bivariate_pid">idtxl.bivariate_pid module</a></li>
<li><a class="reference internal" href="#module-idtxl.multivariate_te">idtxl.multivariate_te module</a></li>
<li><a class="reference internal" href="#module-idtxl.multivariate_mi">idtxl.multivariate_mi module</a></li>
<li><a class="reference internal" href="#module-idtxl.multivariate_pid">idtxl.multivariate_pid module</a></li>
<li><a class="reference internal" href="#module-idtxl.active_information_storage">idtxl.active_information_storage module</a></li>
<li><a class="reference internal" href="#module-idtxl.estimators_jidt">idtxl.estimators_jidt module</a></li>
<li><a class="reference internal" href="#module-idtxl.estimators_opencl">idtxl.estimators_opencl module</a></li>
<li><a class="reference internal" href="#module-idtxl.estimators_multivariate_pid">idtxl.estimators_multivariate_pid module</a></li>
<li><a class="reference internal" href="#module-idtxl.estimators_pid">idtxl.estimators_pid module</a></li>
<li><a class="reference internal" href="#module-idtxl.idtxl_import">idtxl.idtxl_import module</a></li>
<li><a class="reference internal" href="#module-idtxl.idtxl_exceptions">idtxl.idtxl_exceptions module</a></li>
<li><a class="reference internal" href="#module-idtxl.idtxl_io">idtxl.idtxl_io module</a></li>
<li><a class="reference internal" href="#module-idtxl.idtxl_utils">idtxl.idtxl_utils module</a></li>
<li><a class="reference internal" href="#module-idtxl.network_analysis">idtxl.network_analysis module</a></li>
<li><a class="reference internal" href="#module-idtxl.network_inference">idtxl.network_inference module</a></li>
<li><a class="reference internal" href="#module-idtxl.single_process_analysis">idtxl.single_process_analysis module</a></li>
<li><a class="reference internal" href="#module-idtxl.network_comparison">idtxl.network_comparison module</a></li>
<li><a class="reference internal" href="#module-idtxl.results">idtxl.results module</a></li>
<li><a class="reference internal" href="#module-idtxl.stats">idtxl.stats module</a></li>
<li><a class="reference internal" href="#module-idtxl.visualise_graph">idtxl.visualise_graph module</a></li>
<li><a class="reference internal" href="#module-idtxl">Module contents</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="idtxl_helper.html"
                        title="previous chapter">Helper functions</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/idtxl.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="idtxl_helper.html" title="Helper functions"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">IDTxl 1.2.1 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">idtxl package</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Patricia Wollstadt, Joseph T. Lizier, Raul Vicente, Conor Finn, Mario Martinez-Zarzuela, Pedro Mediano, Leonardo Novelli, Michael Wibral.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.5.1.
    </div>
  </body>
</html>